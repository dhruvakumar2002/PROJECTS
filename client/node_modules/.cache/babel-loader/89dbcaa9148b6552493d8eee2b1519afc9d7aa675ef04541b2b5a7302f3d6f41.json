{"ast":null,"code":"var _jsxFileName = \"/Users/dhruva_kumar/Work Space/final project/client/src/pages/Record.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport toast from 'react-hot-toast';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_URL = 'http://192.168.98.141:5001/api/recordings';\n\n// Quality presets for adaptive recording\nconst QUALITY_PRESETS = {\n  high: {\n    video: {\n      width: 1280,\n      height: 720,\n      frameRate: 30,\n      bitrate: 2500000\n    },\n    audio: {\n      sampleRate: 48000,\n      channelCount: 2,\n      bitrate: 128000\n    }\n  },\n  medium: {\n    video: {\n      width: 854,\n      height: 480,\n      frameRate: 25,\n      bitrate: 1000000\n    },\n    audio: {\n      sampleRate: 44100,\n      channelCount: 2,\n      bitrate: 96000\n    }\n  },\n  low: {\n    video: {\n      width: 640,\n      height: 360,\n      frameRate: 20,\n      bitrate: 500000\n    },\n    audio: {\n      sampleRate: 22050,\n      channelCount: 1,\n      bitrate: 64000\n    }\n  },\n  audioOnly: {\n    video: false,\n    audio: {\n      sampleRate: 22050,\n      channelCount: 1,\n      bitrate: 32000\n    }\n  }\n};\nconst Record = () => {\n  _s();\n  var _cameras$currentCamer;\n  const [isRecording, setIsRecording] = useState(false);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [chunks, setChunks] = useState([]);\n  const [stream, setStream] = useState(null);\n  const [cameras, setCameras] = useState([]);\n  const [currentCameraIndex, setCurrentCameraIndex] = useState(0);\n  const [currentQuality, setCurrentQuality] = useState('medium');\n  const [isAudioOnly, setIsAudioOnly] = useState(false);\n  const [networkQuality, setNetworkQuality] = useState('unknown');\n  const [recordingTime, setRecordingTime] = useState(0);\n  const [status, setStatus] = useState('Ready to record');\n  const videoRef = useRef();\n  const recordingTimer = useRef(null);\n  const networkCheckInterval = useRef(null);\n  const streamStateCheck = useRef(null);\n  const chunksRef = useRef([]); // Use ref to store chunks\n\n  // Get available cameras\n  const getCameras = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      setCameras(videoDevices);\n      return videoDevices;\n    } catch (err) {\n      console.error('Error getting cameras:', err);\n      return [];\n    }\n  };\n\n  // Assess network quality for recording\n  const assessNetworkQuality = async () => {\n    try {\n      // Simple network quality assessment for recording\n      const startTime = performance.now();\n      const response = await fetch(API_URL, {\n        method: 'HEAD',\n        cache: 'no-cache'\n      });\n      const endTime = performance.now();\n      const latency = endTime - startTime;\n      let newQuality = currentQuality;\n      let newAudioOnly = isAudioOnly;\n      if (latency > 1000 || !response.ok) {\n        // Poor network - switch to audio only\n        newQuality = 'audioOnly';\n        newAudioOnly = true;\n        setNetworkQuality('poor');\n      } else if (latency > 500) {\n        // Medium network - use low quality\n        newQuality = 'low';\n        newAudioOnly = false;\n        setNetworkQuality('medium');\n      } else if (latency > 200) {\n        // Good network - use medium quality\n        newQuality = 'medium';\n        newAudioOnly = false;\n        setNetworkQuality('good');\n      } else {\n        // Excellent network - use high quality\n        newQuality = 'high';\n        newAudioOnly = false;\n        setNetworkQuality('excellent');\n      }\n\n      // Apply quality changes if needed\n      if (newQuality !== currentQuality || newAudioOnly !== isAudioOnly) {\n        await adjustRecordingQuality(newQuality, newAudioOnly);\n      }\n      setStatus(`Network: ${networkQuality} (${latency.toFixed(0)}ms latency)`);\n    } catch (error) {\n      console.error('Error assessing network quality:', error);\n      // If network check fails, assume poor network and switch to audio only\n      if (currentQuality !== 'audioOnly') {\n        await adjustRecordingQuality('audioOnly', true);\n      }\n    }\n  };\n\n  // Adjust recording quality based on network conditions\n  const adjustRecordingQuality = async (quality, audioOnly = false) => {\n    if (isRecording) {\n      setStatus('Cannot adjust quality while recording');\n      return;\n    }\n    try {\n      setStatus(`Adjusting quality to: ${quality}${audioOnly ? ' (audio only)' : ''}`);\n\n      // Stop current stream if exists\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n\n      // Get new stream with adjusted quality\n      const constraints = audioOnly ? {\n        audio: QUALITY_PRESETS.audioOnly.audio\n      } : {\n        video: {\n          deviceId: cameras[currentCameraIndex] ? {\n            exact: cameras[currentCameraIndex].deviceId\n          } : undefined,\n          ...QUALITY_PRESETS[quality].video\n        },\n        audio: QUALITY_PRESETS[quality].audio\n      };\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n      setCurrentQuality(quality);\n      setIsAudioOnly(audioOnly);\n      setStatus(`Quality adjusted to ${quality}`);\n    } catch (error) {\n      console.error('Error adjusting recording quality:', error);\n      setStatus(`Error adjusting quality: ${error.message}`);\n    }\n  };\n\n  // Manual quality adjustment\n  const setQuality = async quality => {\n    await adjustRecordingQuality(quality, quality === 'audioOnly');\n  };\n\n  // Switch camera\n  const switchCamera = async () => {\n    if (cameras.length < 2) {\n      setStatus('Only one camera available');\n      return;\n    }\n    if (isRecording) {\n      setStatus('Cannot switch camera while recording');\n      return;\n    }\n    const newIndex = (currentCameraIndex + 1) % cameras.length;\n    setCurrentCameraIndex(newIndex);\n    if (stream) {\n      stream.getTracks().forEach(track => track.stop());\n    }\n    try {\n      setStatus('Switching camera...');\n      const constraints = isAudioOnly ? {\n        audio: QUALITY_PRESETS.audioOnly.audio\n      } : {\n        video: {\n          deviceId: {\n            exact: cameras[newIndex].deviceId\n          },\n          ...QUALITY_PRESETS[currentQuality].video\n        },\n        audio: QUALITY_PRESETS[currentQuality].audio\n      };\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      videoRef.current.srcObject = newStream;\n      setStatus('Camera switched!');\n    } catch (err) {\n      setStatus('Error switching camera');\n      console.error('Camera switch error:', err);\n    }\n  };\n\n  // Start recording\n  const startRecording = async () => {\n    if (!stream) {\n      setStatus('No media stream available');\n      return;\n    }\n    try {\n      setStatus('Starting recording...');\n\n      // Start network quality monitoring\n      networkCheckInterval.current = setInterval(assessNetworkQuality, 10000);\n\n      // Clear previous chunks\n      chunksRef.current = [];\n      setChunks([]);\n\n      // Check for supported MIME types\n      const mimeTypes = ['video/webm;codecs=vp8,opus', 'video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4'];\n      let selectedMimeType = null;\n      for (const mimeType of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(mimeType)) {\n          selectedMimeType = mimeType;\n          console.log('Using MIME type:', mimeType);\n          break;\n        }\n      }\n      if (!selectedMimeType) {\n        throw new Error('No supported video MIME type found');\n      }\n      console.log('Starting MediaRecorder with:', {\n        mimeType: selectedMimeType,\n        streamTracks: stream.getTracks().length,\n        videoTracks: stream.getVideoTracks().length,\n        audioTracks: stream.getAudioTracks().length\n      });\n      const recorder = new window.MediaRecorder(stream, {\n        mimeType: selectedMimeType\n      });\n      setMediaRecorder(recorder);\n      setRecordingTime(0);\n      recorder.ondataavailable = e => {\n        console.log('Data available:', e.data.size, 'bytes, type:', e.data.type);\n        if (e.data.size > 0) {\n          chunksRef.current.push(e.data);\n          setChunks(prev => [...prev, e.data]);\n        } else {\n          console.warn('Received empty data chunk');\n        }\n      };\n      recorder.onerror = event => {\n        console.error('MediaRecorder error:', event.error);\n        console.error('Error details:', {\n          name: event.error.name,\n          message: event.error.message,\n          code: event.error.code\n        });\n        setStatus(`Recording error: ${event.error.name} - ${event.error.message}`);\n        setIsRecording(false);\n\n        // Clear intervals\n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n      };\n      recorder.onstart = () => {\n        console.log('MediaRecorder started successfully');\n        console.log('Recorder state:', recorder.state);\n        setStatus('Recording started successfully');\n      };\n      recorder.onpause = () => {\n        console.log('MediaRecorder paused');\n        setStatus('Recording paused');\n      };\n      recorder.onresume = () => {\n        console.log('MediaRecorder resumed');\n        setStatus('Recording resumed');\n      };\n      recorder.onstop = async () => {\n        console.log('Recording stopped. Total chunks:', chunksRef.current.length);\n        console.log('Total data size:', chunksRef.current.reduce((total, chunk) => total + chunk.size, 0), 'bytes');\n        console.log('Final recorder state:', recorder.state);\n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        if (chunksRef.current.length === 0) {\n          setStatus('Error: No recording data captured');\n          console.error('No chunks available for recording');\n          return;\n        }\n        const blob = new Blob(chunksRef.current, {\n          type: selectedMimeType\n        });\n        console.log('Blob created:', blob.size, 'bytes');\n        if (blob.size === 0) {\n          setStatus('Error: Recording file is empty');\n          console.error('Blob size is 0');\n          return;\n        }\n\n        // Upload to backend only - no automatic download\n        const formData = new FormData();\n        const filename = `recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.${selectedMimeType.includes('webm') ? 'webm' : 'mp4'}`;\n        formData.append('file', blob, filename);\n        try {\n          setStatus('Uploading recording...');\n          const response = await fetch(API_URL, {\n            method: 'POST',\n            body: formData\n          });\n          if (response.ok) {\n            const result = await response.json();\n            console.log('Upload successful:', result);\n            setStatus('Recording saved successfully! You can view it in the Playback page.');\n          } else {\n            const errorText = await response.text();\n            console.error('Upload failed:', errorText);\n            setStatus('Error saving recording to server');\n          }\n        } catch (err) {\n          setStatus('Error uploading recording');\n          console.error('Upload error:', err);\n        }\n      };\n\n      // Try with a larger timeslice to prevent browser limitations\n      recorder.start(5000); // Request data every 5 seconds instead of 1\n      setIsRecording(true);\n      setStatus('Recording...');\n\n      // Start recording timer\n      recordingTimer.current = setInterval(() => {\n        setRecordingTime(prev => prev + 1);\n      }, 1000);\n\n      // Monitor stream state\n      const streamStateCheck = setInterval(() => {\n        if (stream) {\n          const videoTrack = stream.getVideoTracks()[0];\n          const audioTrack = stream.getAudioTracks()[0];\n          if (videoTrack && videoTrack.readyState === 'ended') {\n            console.error('Video track ended unexpectedly');\n            setStatus('Video track ended - stopping recording');\n            recorder.stop();\n            clearInterval(streamStateCheck);\n          }\n          if (audioTrack && audioTrack.readyState === 'ended') {\n            console.error('Audio track ended unexpectedly');\n            setStatus('Audio track ended - stopping recording');\n            recorder.stop();\n            clearInterval(streamStateCheck);\n          }\n\n          // Check MediaRecorder state\n          if (recorder.state === 'inactive') {\n            console.error('MediaRecorder became inactive unexpectedly');\n            setStatus('MediaRecorder stopped unexpectedly');\n            setIsRecording(false);\n            clearInterval(streamStateCheck);\n          }\n\n          // Log stream state every 5 seconds for more frequent monitoring\n          if (recordingTime % 5 === 0) {\n            console.log('Stream state check:', {\n              videoTrack: videoTrack ? {\n                readyState: videoTrack.readyState,\n                enabled: videoTrack.enabled\n              } : 'none',\n              audioTrack: audioTrack ? {\n                readyState: audioTrack.readyState,\n                enabled: audioTrack.enabled\n              } : 'none',\n              recorderState: recorder.state,\n              recordingTime: recordingTime,\n              chunksCount: chunksRef.current.length,\n              totalDataSize: chunksRef.current.reduce((total, chunk) => total + chunk.size, 0)\n            });\n          }\n        }\n      }, 1000);\n\n      // Store the interval reference for cleanup\n      streamStateCheck.current = streamStateCheck;\n    } catch (error) {\n      setStatus('Error starting recording');\n      console.error('Recording error:', error);\n    }\n  };\n\n  // Stop recording\n  const stopRecording = () => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      setStatus('Stopping recording...');\n    }\n  };\n\n  // Initialize camera access\n  useEffect(() => {\n    const initCamera = async () => {\n      try {\n        setStatus('Accessing camera...');\n        await getCameras();\n\n        // Start with medium quality\n        const initialStream = await navigator.mediaDevices.getUserMedia({\n          video: QUALITY_PRESETS.medium.video,\n          audio: QUALITY_PRESETS.medium.audio\n        });\n        setStream(initialStream);\n        if (videoRef.current) {\n          videoRef.current.srcObject = initialStream;\n        }\n        setStatus('Camera ready');\n      } catch (err) {\n        setStatus('Error accessing camera/microphone');\n        console.error('Camera access error:', err);\n      }\n    };\n    initCamera();\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (networkCheckInterval.current) {\n        clearInterval(networkCheckInterval.current);\n      }\n      if (recordingTimer.current) {\n        clearInterval(recordingTimer.current);\n      }\n      if (streamStateCheck.current) {\n        clearInterval(streamStateCheck.current);\n      }\n    };\n  }, []);\n\n  // Format recording time\n  const formatTime = seconds => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"max-w-4xl mx-auto mt-10 bg-white rounded-lg shadow p-6\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      className: \"text-2xl font-bold mb-4 text-blue-700\",\n      children: \"Record Video\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 476,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-4 p-3 bg-gray-100 rounded\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-700\",\n        children: [\"Status: \", status]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 479,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-700\",\n        children: [\"Quality: \", currentQuality, \" \", isAudioOnly && '(Audio Only)']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 480,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-700\",\n        children: [\"Network: \", networkQuality]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 481,\n        columnNumber: 9\n      }, this), isRecording && /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-red-600 font-semibold\",\n        children: [\"Recording: \", formatTime(recordingTime)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 483,\n        columnNumber: 11\n      }, this), cameras.length > 1 && /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-xs text-gray-500 mt-1\",\n        children: [\"Available cameras: \", cameras.length, \" | Current: \", ((_cameras$currentCamer = cameras[currentCameraIndex]) === null || _cameras$currentCamer === void 0 ? void 0 : _cameras$currentCamer.label) || 'Camera ' + (currentCameraIndex + 1)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 486,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 478,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"flex gap-4 mb-6 flex-wrap\",\n      children: [!isRecording ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: startRecording,\n        className: \"bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\",\n        children: \"Start Recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 494,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: stopRecording,\n        className: \"bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\",\n        children: \"Stop Recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 501,\n        columnNumber: 11\n      }, this), cameras.length > 1 && /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: switchCamera,\n        disabled: isRecording,\n        className: `px-4 py-3 rounded-lg shadow-lg font-semibold ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-yellow-600 hover:bg-yellow-700 text-white'}`,\n        children: \"Switch Camera\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 510,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex gap-2\",\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('high'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'high' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"High\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 525,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('medium'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'medium' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"Medium\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 538,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('low'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'low' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"Low\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 551,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('audioOnly'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'audioOnly' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"Audio Only\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 564,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 524,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 492,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"relative\",\n      children: [/*#__PURE__*/_jsxDEV(\"video\", {\n        ref: videoRef,\n        autoPlay: true,\n        playsInline: true,\n        muted: true,\n        className: \"rounded-lg shadow-lg border-2 border-blue-200 w-full h-96 bg-black\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 581,\n        columnNumber: 9\n      }, this), isAudioOnly && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"absolute top-4 left-4 p-2 bg-yellow-100 rounded text-center\",\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"text-yellow-800 text-sm font-semibold\",\n          children: \"Audio Only Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 591,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"text-yellow-700 text-xs\",\n          children: \"Poor Network Detected\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 592,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 590,\n        columnNumber: 11\n      }, this), isRecording && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"absolute top-4 right-4 p-2 bg-red-600 rounded text-white\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"flex items-center gap-2\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"w-3 h-3 bg-white rounded-full animate-pulse\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 599,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"font-semibold\",\n            children: \"REC\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 600,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 598,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 597,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 580,\n      columnNumber: 7\n    }, this), isRecording && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-4 p-3 bg-red-100 rounded\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-red-700 text-sm\",\n        children: [\"\\uD83D\\uDD34 Recording in progress... \", formatTime(recordingTime)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 608,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 607,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-6 p-4 bg-blue-50 rounded\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        className: \"font-semibold text-blue-800 mb-2\",\n        children: \"Adaptive Quality Features:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 613,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        className: \"text-sm text-blue-700 space-y-1\",\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Automatic quality adjustment based on network conditions\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 615,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Fallback to audio-only recording in poor network\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 616,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Manual quality control for optimal recording\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 617,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Real-time network quality monitoring\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 618,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Automatic camera switching support\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 619,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 614,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 612,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 475,\n    columnNumber: 5\n  }, this);\n};\n_s(Record, \"tLB/w5UP+j+snzahW2W6DzL/9b8=\");\n_c = Record;\nexport default Record;\nvar _c;\n$RefreshReg$(_c, \"Record\");","map":{"version":3,"names":["React","useRef","useState","useEffect","toast","jsxDEV","_jsxDEV","API_URL","QUALITY_PRESETS","high","video","width","height","frameRate","bitrate","audio","sampleRate","channelCount","medium","low","audioOnly","Record","_s","_cameras$currentCamer","isRecording","setIsRecording","mediaRecorder","setMediaRecorder","chunks","setChunks","stream","setStream","cameras","setCameras","currentCameraIndex","setCurrentCameraIndex","currentQuality","setCurrentQuality","isAudioOnly","setIsAudioOnly","networkQuality","setNetworkQuality","recordingTime","setRecordingTime","status","setStatus","videoRef","recordingTimer","networkCheckInterval","streamStateCheck","chunksRef","getCameras","devices","navigator","mediaDevices","enumerateDevices","videoDevices","filter","device","kind","err","console","error","assessNetworkQuality","startTime","performance","now","response","fetch","method","cache","endTime","latency","newQuality","newAudioOnly","ok","adjustRecordingQuality","toFixed","quality","getTracks","forEach","track","stop","constraints","deviceId","exact","undefined","newStream","getUserMedia","current","srcObject","message","setQuality","switchCamera","length","newIndex","startRecording","setInterval","mimeTypes","selectedMimeType","mimeType","MediaRecorder","isTypeSupported","log","Error","streamTracks","videoTracks","getVideoTracks","audioTracks","getAudioTracks","recorder","window","ondataavailable","e","data","size","type","push","prev","warn","onerror","event","name","code","clearInterval","onstart","state","onpause","onresume","onstop","reduce","total","chunk","blob","Blob","formData","FormData","filename","Date","toISOString","slice","replace","includes","append","body","result","json","errorText","text","start","videoTrack","audioTrack","readyState","enabled","recorderState","chunksCount","totalDataSize","stopRecording","initCamera","initialStream","formatTime","seconds","mins","Math","floor","secs","toString","padStart","className","children","fileName","_jsxFileName","lineNumber","columnNumber","label","onClick","disabled","ref","autoPlay","playsInline","muted","_c","$RefreshReg$"],"sources":["/Users/dhruva_kumar/Work Space/final project/client/src/pages/Record.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport toast from 'react-hot-toast';\n\nconst API_URL = 'http://192.168.98.141:5001/api/recordings';\n\n// Quality presets for adaptive recording\nconst QUALITY_PRESETS = {\n  high: {\n    video: { width: 1280, height: 720, frameRate: 30, bitrate: 2500000 },\n    audio: { sampleRate: 48000, channelCount: 2, bitrate: 128000 }\n  },\n  medium: {\n    video: { width: 854, height: 480, frameRate: 25, bitrate: 1000000 },\n    audio: { sampleRate: 44100, channelCount: 2, bitrate: 96000 }\n  },\n  low: {\n    video: { width: 640, height: 360, frameRate: 20, bitrate: 500000 },\n    audio: { sampleRate: 22050, channelCount: 1, bitrate: 64000 }\n  },\n  audioOnly: {\n    video: false,\n    audio: { sampleRate: 22050, channelCount: 1, bitrate: 32000 }\n  }\n};\n\nconst Record = () => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [chunks, setChunks] = useState([]);\n  const [stream, setStream] = useState(null);\n  const [cameras, setCameras] = useState([]);\n  const [currentCameraIndex, setCurrentCameraIndex] = useState(0);\n  const [currentQuality, setCurrentQuality] = useState('medium');\n  const [isAudioOnly, setIsAudioOnly] = useState(false);\n  const [networkQuality, setNetworkQuality] = useState('unknown');\n  const [recordingTime, setRecordingTime] = useState(0);\n  const [status, setStatus] = useState('Ready to record');\n\n  const videoRef = useRef();\n  const recordingTimer = useRef(null);\n  const networkCheckInterval = useRef(null);\n  const streamStateCheck = useRef(null);\n  const chunksRef = useRef([]); // Use ref to store chunks\n\n  // Get available cameras\n  const getCameras = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      setCameras(videoDevices);\n      return videoDevices;\n    } catch (err) {\n      console.error('Error getting cameras:', err);\n      return [];\n    }\n  };\n\n  // Assess network quality for recording\n  const assessNetworkQuality = async () => {\n    try {\n      // Simple network quality assessment for recording\n      const startTime = performance.now();\n      const response = await fetch(API_URL, { \n        method: 'HEAD',\n        cache: 'no-cache'\n      });\n      const endTime = performance.now();\n      const latency = endTime - startTime;\n\n      let newQuality = currentQuality;\n      let newAudioOnly = isAudioOnly;\n\n      if (latency > 1000 || !response.ok) {\n        // Poor network - switch to audio only\n        newQuality = 'audioOnly';\n        newAudioOnly = true;\n        setNetworkQuality('poor');\n      } else if (latency > 500) {\n        // Medium network - use low quality\n        newQuality = 'low';\n        newAudioOnly = false;\n        setNetworkQuality('medium');\n      } else if (latency > 200) {\n        // Good network - use medium quality\n        newQuality = 'medium';\n        newAudioOnly = false;\n        setNetworkQuality('good');\n      } else {\n        // Excellent network - use high quality\n        newQuality = 'high';\n        newAudioOnly = false;\n        setNetworkQuality('excellent');\n      }\n\n      // Apply quality changes if needed\n      if (newQuality !== currentQuality || newAudioOnly !== isAudioOnly) {\n        await adjustRecordingQuality(newQuality, newAudioOnly);\n      }\n\n      setStatus(`Network: ${networkQuality} (${latency.toFixed(0)}ms latency)`);\n    } catch (error) {\n      console.error('Error assessing network quality:', error);\n      // If network check fails, assume poor network and switch to audio only\n      if (currentQuality !== 'audioOnly') {\n        await adjustRecordingQuality('audioOnly', true);\n      }\n    }\n  };\n\n  // Adjust recording quality based on network conditions\n  const adjustRecordingQuality = async (quality, audioOnly = false) => {\n    if (isRecording) {\n      setStatus('Cannot adjust quality while recording');\n      return;\n    }\n\n    try {\n      setStatus(`Adjusting quality to: ${quality}${audioOnly ? ' (audio only)' : ''}`);\n      \n      // Stop current stream if exists\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      \n      // Get new stream with adjusted quality\n      const constraints = audioOnly ? \n        { audio: QUALITY_PRESETS.audioOnly.audio } :\n        { \n          video: { \n            deviceId: cameras[currentCameraIndex] ? { exact: cameras[currentCameraIndex].deviceId } : undefined,\n            ...QUALITY_PRESETS[quality].video \n          },\n          audio: QUALITY_PRESETS[quality].audio\n        };\n\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n\n      setCurrentQuality(quality);\n      setIsAudioOnly(audioOnly);\n      setStatus(`Quality adjusted to ${quality}`);\n    } catch (error) {\n      console.error('Error adjusting recording quality:', error);\n      setStatus(`Error adjusting quality: ${error.message}`);\n    }\n  };\n\n  // Manual quality adjustment\n  const setQuality = async (quality) => {\n    await adjustRecordingQuality(quality, quality === 'audioOnly');\n  };\n\n  // Switch camera\n  const switchCamera = async () => {\n    if (cameras.length < 2) {\n      setStatus('Only one camera available');\n      return;\n    }\n\n    if (isRecording) {\n      setStatus('Cannot switch camera while recording');\n      return;\n    }\n\n    const newIndex = (currentCameraIndex + 1) % cameras.length;\n    setCurrentCameraIndex(newIndex);\n    \n    if (stream) {\n      stream.getTracks().forEach(track => track.stop());\n    }\n\n    try {\n      setStatus('Switching camera...');\n      const constraints = isAudioOnly ? \n        { audio: QUALITY_PRESETS.audioOnly.audio } :\n        { \n          video: { \n            deviceId: { exact: cameras[newIndex].deviceId }, \n            ...QUALITY_PRESETS[currentQuality].video \n          },\n          audio: QUALITY_PRESETS[currentQuality].audio\n        };\n\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      videoRef.current.srcObject = newStream;\n      setStatus('Camera switched!');\n    } catch (err) {\n      setStatus('Error switching camera');\n      console.error('Camera switch error:', err);\n    }\n  };\n\n  // Start recording\n  const startRecording = async () => {\n    if (!stream) {\n      setStatus('No media stream available');\n      return;\n    }\n\n    try {\n      setStatus('Starting recording...');\n      \n      // Start network quality monitoring\n      networkCheckInterval.current = setInterval(assessNetworkQuality, 10000);\n      \n      // Clear previous chunks\n      chunksRef.current = [];\n      setChunks([]);\n      \n      // Check for supported MIME types\n      const mimeTypes = [\n        'video/webm;codecs=vp8,opus',\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=vp8',\n        'video/webm',\n        'video/mp4'\n      ];\n      \n      let selectedMimeType = null;\n      for (const mimeType of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(mimeType)) {\n          selectedMimeType = mimeType;\n          console.log('Using MIME type:', mimeType);\n          break;\n        }\n      }\n      \n      if (!selectedMimeType) {\n        throw new Error('No supported video MIME type found');\n      }\n      \n      console.log('Starting MediaRecorder with:', {\n        mimeType: selectedMimeType,\n        streamTracks: stream.getTracks().length,\n        videoTracks: stream.getVideoTracks().length,\n        audioTracks: stream.getAudioTracks().length\n      });\n      \n      const recorder = new window.MediaRecorder(stream, {\n        mimeType: selectedMimeType\n      });\n      \n      setMediaRecorder(recorder);\n      setRecordingTime(0);\n      \n      recorder.ondataavailable = (e) => {\n        console.log('Data available:', e.data.size, 'bytes, type:', e.data.type);\n        if (e.data.size > 0) {\n          chunksRef.current.push(e.data);\n          setChunks(prev => [...prev, e.data]);\n        } else {\n          console.warn('Received empty data chunk');\n        }\n      };\n      \n      recorder.onerror = (event) => {\n        console.error('MediaRecorder error:', event.error);\n        console.error('Error details:', {\n          name: event.error.name,\n          message: event.error.message,\n          code: event.error.code\n        });\n        setStatus(`Recording error: ${event.error.name} - ${event.error.message}`);\n        setIsRecording(false);\n        \n        // Clear intervals\n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n      };\n      \n      recorder.onstart = () => {\n        console.log('MediaRecorder started successfully');\n        console.log('Recorder state:', recorder.state);\n        setStatus('Recording started successfully');\n      };\n      \n      recorder.onpause = () => {\n        console.log('MediaRecorder paused');\n        setStatus('Recording paused');\n      };\n      \n      recorder.onresume = () => {\n        console.log('MediaRecorder resumed');\n        setStatus('Recording resumed');\n      };\n      \n      recorder.onstop = async () => {\n        console.log('Recording stopped. Total chunks:', chunksRef.current.length);\n        console.log('Total data size:', chunksRef.current.reduce((total, chunk) => total + chunk.size, 0), 'bytes');\n        console.log('Final recorder state:', recorder.state);\n        \n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        \n        if (chunksRef.current.length === 0) {\n          setStatus('Error: No recording data captured');\n          console.error('No chunks available for recording');\n          return;\n        }\n        \n        const blob = new Blob(chunksRef.current, { type: selectedMimeType });\n        console.log('Blob created:', blob.size, 'bytes');\n        \n        if (blob.size === 0) {\n          setStatus('Error: Recording file is empty');\n          console.error('Blob size is 0');\n          return;\n        }\n        \n        // Upload to backend only - no automatic download\n        const formData = new FormData();\n        const filename = `recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.${selectedMimeType.includes('webm') ? 'webm' : 'mp4'}`;\n        formData.append('file', blob, filename);\n        \n        try {\n          setStatus('Uploading recording...');\n          const response = await fetch(API_URL, { \n            method: 'POST', \n            body: formData \n          });\n          \n          if (response.ok) {\n            const result = await response.json();\n            console.log('Upload successful:', result);\n            setStatus('Recording saved successfully! You can view it in the Playback page.');\n          } else {\n            const errorText = await response.text();\n            console.error('Upload failed:', errorText);\n            setStatus('Error saving recording to server');\n          }\n        } catch (err) {\n          setStatus('Error uploading recording');\n          console.error('Upload error:', err);\n        }\n      };\n      \n      // Try with a larger timeslice to prevent browser limitations\n      recorder.start(5000); // Request data every 5 seconds instead of 1\n      setIsRecording(true);\n      setStatus('Recording...');\n      \n      // Start recording timer\n      recordingTimer.current = setInterval(() => {\n        setRecordingTime(prev => prev + 1);\n      }, 1000);\n      \n      // Monitor stream state\n      const streamStateCheck = setInterval(() => {\n        if (stream) {\n          const videoTrack = stream.getVideoTracks()[0];\n          const audioTrack = stream.getAudioTracks()[0];\n          \n          if (videoTrack && videoTrack.readyState === 'ended') {\n            console.error('Video track ended unexpectedly');\n            setStatus('Video track ended - stopping recording');\n            recorder.stop();\n            clearInterval(streamStateCheck);\n          }\n          \n          if (audioTrack && audioTrack.readyState === 'ended') {\n            console.error('Audio track ended unexpectedly');\n            setStatus('Audio track ended - stopping recording');\n            recorder.stop();\n            clearInterval(streamStateCheck);\n          }\n          \n          // Check MediaRecorder state\n          if (recorder.state === 'inactive') {\n            console.error('MediaRecorder became inactive unexpectedly');\n            setStatus('MediaRecorder stopped unexpectedly');\n            setIsRecording(false);\n            clearInterval(streamStateCheck);\n          }\n          \n          // Log stream state every 5 seconds for more frequent monitoring\n          if (recordingTime % 5 === 0) {\n            console.log('Stream state check:', {\n              videoTrack: videoTrack ? { readyState: videoTrack.readyState, enabled: videoTrack.enabled } : 'none',\n              audioTrack: audioTrack ? { readyState: audioTrack.readyState, enabled: audioTrack.enabled } : 'none',\n              recorderState: recorder.state,\n              recordingTime: recordingTime,\n              chunksCount: chunksRef.current.length,\n              totalDataSize: chunksRef.current.reduce((total, chunk) => total + chunk.size, 0)\n            });\n          }\n        }\n      }, 1000);\n      \n      // Store the interval reference for cleanup\n      streamStateCheck.current = streamStateCheck;\n      \n    } catch (error) {\n      setStatus('Error starting recording');\n      console.error('Recording error:', error);\n    }\n  };\n\n  // Stop recording\n  const stopRecording = () => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      setStatus('Stopping recording...');\n    }\n  };\n\n  // Initialize camera access\n  useEffect(() => {\n    const initCamera = async () => {\n      try {\n        setStatus('Accessing camera...');\n        await getCameras();\n        \n        // Start with medium quality\n        const initialStream = await navigator.mediaDevices.getUserMedia({\n          video: QUALITY_PRESETS.medium.video,\n          audio: QUALITY_PRESETS.medium.audio\n        });\n        \n        setStream(initialStream);\n        if (videoRef.current) {\n          videoRef.current.srcObject = initialStream;\n        }\n        setStatus('Camera ready');\n      } catch (err) {\n        setStatus('Error accessing camera/microphone');\n        console.error('Camera access error:', err);\n      }\n    };\n\n    initCamera();\n\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (networkCheckInterval.current) {\n        clearInterval(networkCheckInterval.current);\n      }\n      if (recordingTimer.current) {\n        clearInterval(recordingTimer.current);\n      }\n      if (streamStateCheck.current) {\n        clearInterval(streamStateCheck.current);\n      }\n    };\n  }, []);\n\n  // Format recording time\n  const formatTime = (seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  return (\n    <div className=\"max-w-4xl mx-auto mt-10 bg-white rounded-lg shadow p-6\">\n      <h2 className=\"text-2xl font-bold mb-4 text-blue-700\">Record Video</h2>\n      \n      <div className=\"mb-4 p-3 bg-gray-100 rounded\">\n        <p className=\"text-sm text-gray-700\">Status: {status}</p>\n        <p className=\"text-sm text-gray-700\">Quality: {currentQuality} {isAudioOnly && '(Audio Only)'}</p>\n        <p className=\"text-sm text-gray-700\">Network: {networkQuality}</p>\n        {isRecording && (\n          <p className=\"text-sm text-red-600 font-semibold\">Recording: {formatTime(recordingTime)}</p>\n        )}\n        {cameras.length > 1 && (\n          <p className=\"text-xs text-gray-500 mt-1\">\n            Available cameras: {cameras.length} | Current: {cameras[currentCameraIndex]?.label || 'Camera ' + (currentCameraIndex + 1)}\n          </p>\n        )}\n      </div>\n\n      <div className=\"flex gap-4 mb-6 flex-wrap\">\n        {!isRecording ? (\n          <button\n            onClick={startRecording}\n            className=\"bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\"\n          >\n            Start Recording\n          </button>\n        ) : (\n          <button\n            onClick={stopRecording}\n            className=\"bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\"\n          >\n            Stop Recording\n          </button>\n        )}\n        \n        {cameras.length > 1 && (\n          <button\n            onClick={switchCamera}\n            disabled={isRecording}\n            className={`px-4 py-3 rounded-lg shadow-lg font-semibold ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : 'bg-yellow-600 hover:bg-yellow-700 text-white'\n            }`}\n          >\n            Switch Camera\n          </button>\n        )}\n        \n        {/* Manual Quality Controls */}\n        <div className=\"flex gap-2\">\n          <button\n            onClick={() => setQuality('high')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'high' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            High\n          </button>\n          <button\n            onClick={() => setQuality('medium')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'medium' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            Medium\n          </button>\n          <button\n            onClick={() => setQuality('low')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'low' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            Low\n          </button>\n          <button\n            onClick={() => setQuality('audioOnly')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'audioOnly' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            Audio Only\n          </button>\n        </div>\n      </div>\n\n      <div className=\"relative\">\n        <video\n          ref={videoRef}\n          autoPlay\n          playsInline\n          muted\n          className=\"rounded-lg shadow-lg border-2 border-blue-200 w-full h-96 bg-black\"\n        />\n        \n        {isAudioOnly && (\n          <div className=\"absolute top-4 left-4 p-2 bg-yellow-100 rounded text-center\">\n            <p className=\"text-yellow-800 text-sm font-semibold\">Audio Only Mode</p>\n            <p className=\"text-yellow-700 text-xs\">Poor Network Detected</p>\n          </div>\n        )}\n        \n        {isRecording && (\n          <div className=\"absolute top-4 right-4 p-2 bg-red-600 rounded text-white\">\n            <div className=\"flex items-center gap-2\">\n              <div className=\"w-3 h-3 bg-white rounded-full animate-pulse\"></div>\n              <span className=\"font-semibold\">REC</span>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {isRecording && (\n        <div className=\"mt-4 p-3 bg-red-100 rounded\">\n          <p className=\"text-red-700 text-sm\"> Recording in progress... {formatTime(recordingTime)}</p>\n        </div>\n      )}\n\n      <div className=\"mt-6 p-4 bg-blue-50 rounded\">\n        <h3 className=\"font-semibold text-blue-800 mb-2\">Adaptive Quality Features:</h3>\n        <ul className=\"text-sm text-blue-700 space-y-1\">\n          <li> Automatic quality adjustment based on network conditions</li>\n          <li> Fallback to audio-only recording in poor network</li>\n          <li> Manual quality control for optimal recording</li>\n          <li> Real-time network quality monitoring</li>\n          <li> Automatic camera switching support</li>\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport default Record; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}