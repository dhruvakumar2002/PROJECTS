{"ast":null,"code":"var _jsxFileName = \"/Users/dhruva_kumar/Work Space/final project/client/src/pages/Record.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport toast from 'react-hot-toast';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_URL = 'http://192.168.98.141:5001/api/recordings';\n\n// Quality presets for adaptive recording\nconst QUALITY_PRESETS = {\n  high: {\n    video: {\n      width: 1280,\n      height: 720,\n      frameRate: 30,\n      bitrate: 2500000\n    },\n    audio: {\n      sampleRate: 48000,\n      channelCount: 2,\n      bitrate: 128000\n    }\n  },\n  medium: {\n    video: {\n      width: 854,\n      height: 480,\n      frameRate: 25,\n      bitrate: 1000000\n    },\n    audio: {\n      sampleRate: 44100,\n      channelCount: 2,\n      bitrate: 96000\n    }\n  },\n  low: {\n    video: {\n      width: 640,\n      height: 360,\n      frameRate: 20,\n      bitrate: 500000\n    },\n    audio: {\n      sampleRate: 22050,\n      channelCount: 1,\n      bitrate: 64000\n    }\n  },\n  audioOnly: {\n    video: false,\n    audio: {\n      sampleRate: 22050,\n      channelCount: 1,\n      bitrate: 32000\n    }\n  }\n};\nconst Record = () => {\n  _s();\n  var _cameras$currentCamer;\n  const [isRecording, setIsRecording] = useState(false);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [chunks, setChunks] = useState([]);\n  const [stream, setStream] = useState(null);\n  const [cameras, setCameras] = useState([]);\n  const [currentCameraIndex, setCurrentCameraIndex] = useState(0);\n  const [currentQuality, setCurrentQuality] = useState('medium');\n  const [isAudioOnly, setIsAudioOnly] = useState(false);\n  const [networkQuality, setNetworkQuality] = useState('unknown');\n  const [recordingTime, setRecordingTime] = useState(0);\n  const [status, setStatus] = useState('Ready to record');\n  const videoRef = useRef();\n  const recordingTimer = useRef(null);\n  const networkCheckInterval = useRef(null);\n  const streamStateCheck = useRef(null);\n  const keepAliveInterval = useRef(null);\n  const chunksRef = useRef([]); // Use ref to store chunks\n\n  // Get available cameras\n  const getCameras = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      setCameras(videoDevices);\n      return videoDevices;\n    } catch (err) {\n      console.error('Error getting cameras:', err);\n      return [];\n    }\n  };\n\n  // Assess network quality for recording\n  const assessNetworkQuality = async () => {\n    try {\n      // Simple network quality assessment for recording\n      const startTime = performance.now();\n      const response = await fetch(API_URL, {\n        method: 'HEAD',\n        cache: 'no-cache'\n      });\n      const endTime = performance.now();\n      const latency = endTime - startTime;\n      let newQuality = currentQuality;\n      let newAudioOnly = isAudioOnly;\n      if (latency > 1000 || !response.ok) {\n        // Poor network - switch to audio only\n        newQuality = 'audioOnly';\n        newAudioOnly = true;\n        setNetworkQuality('poor');\n      } else if (latency > 500) {\n        // Medium network - use low quality\n        newQuality = 'low';\n        newAudioOnly = false;\n        setNetworkQuality('medium');\n      } else if (latency > 200) {\n        // Good network - use medium quality\n        newQuality = 'medium';\n        newAudioOnly = false;\n        setNetworkQuality('good');\n      } else {\n        // Excellent network - use high quality\n        newQuality = 'high';\n        newAudioOnly = false;\n        setNetworkQuality('excellent');\n      }\n\n      // Apply quality changes if needed\n      if (newQuality !== currentQuality || newAudioOnly !== isAudioOnly) {\n        await adjustRecordingQuality(newQuality, newAudioOnly);\n      }\n      setStatus(`Network: ${networkQuality} (${latency.toFixed(0)}ms latency)`);\n    } catch (error) {\n      console.error('Error assessing network quality:', error);\n      // If network check fails, assume poor network and switch to audio only\n      if (currentQuality !== 'audioOnly') {\n        await adjustRecordingQuality('audioOnly', true);\n      }\n    }\n  };\n\n  // Adjust recording quality based on network conditions\n  const adjustRecordingQuality = async (quality, audioOnly = false) => {\n    if (isRecording) {\n      setStatus('Cannot adjust quality while recording');\n      return;\n    }\n    try {\n      setStatus(`Adjusting quality to: ${quality}${audioOnly ? ' (audio only)' : ''}`);\n\n      // Stop current stream if exists\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n\n      // Get new stream with adjusted quality\n      const constraints = audioOnly ? {\n        audio: QUALITY_PRESETS.audioOnly.audio\n      } : {\n        video: {\n          deviceId: cameras[currentCameraIndex] ? {\n            exact: cameras[currentCameraIndex].deviceId\n          } : undefined,\n          ...QUALITY_PRESETS[quality].video\n        },\n        audio: QUALITY_PRESETS[quality].audio\n      };\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n      setCurrentQuality(quality);\n      setIsAudioOnly(audioOnly);\n      setStatus(`Quality adjusted to ${quality}`);\n    } catch (error) {\n      console.error('Error adjusting recording quality:', error);\n      setStatus(`Error adjusting quality: ${error.message}`);\n    }\n  };\n\n  // Manual quality adjustment\n  const setQuality = async quality => {\n    await adjustRecordingQuality(quality, quality === 'audioOnly');\n  };\n\n  // Switch camera\n  const switchCamera = async () => {\n    if (cameras.length < 2) {\n      setStatus('Only one camera available');\n      return;\n    }\n    if (isRecording) {\n      setStatus('Cannot switch camera while recording');\n      return;\n    }\n    const newIndex = (currentCameraIndex + 1) % cameras.length;\n    setCurrentCameraIndex(newIndex);\n    if (stream) {\n      stream.getTracks().forEach(track => track.stop());\n    }\n    try {\n      setStatus('Switching camera...');\n      const constraints = isAudioOnly ? {\n        audio: QUALITY_PRESETS.audioOnly.audio\n      } : {\n        video: {\n          deviceId: {\n            exact: cameras[newIndex].deviceId\n          },\n          ...QUALITY_PRESETS[currentQuality].video\n        },\n        audio: QUALITY_PRESETS[currentQuality].audio\n      };\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      videoRef.current.srcObject = newStream;\n      setStatus('Camera switched!');\n    } catch (err) {\n      setStatus('Error switching camera');\n      console.error('Camera switch error:', err);\n    }\n  };\n\n  // Start recording\n  const startRecording = async () => {\n    if (!stream) {\n      setStatus('No media stream available');\n      return;\n    }\n    try {\n      setStatus('Starting recording...');\n\n      // Reset restart flag for new recording session\n      window.recordingRestarted = false;\n\n      // Start network quality monitoring\n      networkCheckInterval.current = setInterval(assessNetworkQuality, 10000);\n\n      // Clear previous chunks\n      chunksRef.current = [];\n      setChunks([]);\n\n      // Detect browser for potential limitations\n      const userAgent = navigator.userAgent;\n      const isChrome = userAgent.includes('Chrome');\n      const isFirefox = userAgent.includes('Firefox');\n      const isSafari = userAgent.includes('Safari') && !userAgent.includes('Chrome');\n      console.log('Browser detection:', {\n        isChrome,\n        isFirefox,\n        isSafari,\n        userAgent\n      });\n\n      // Check for supported MIME types with browser-specific preferences\n      const mimeTypes = isChrome ? ['video/webm;codecs=vp8,opus', 'video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8', 'video/webm'] : isFirefox ? ['video/webm;codecs=vp8,opus', 'video/webm;codecs=vp8', 'video/webm'] : isSafari ? ['video/mp4', 'video/webm'] : ['video/webm;codecs=vp8,opus', 'video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4'];\n      let selectedMimeType = null;\n      for (const mimeType of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(mimeType)) {\n          selectedMimeType = mimeType;\n          console.log('Using MIME type:', mimeType);\n          break;\n        }\n      }\n      if (!selectedMimeType) {\n        throw new Error('No supported video MIME type found');\n      }\n      console.log('Starting MediaRecorder with:', {\n        mimeType: selectedMimeType,\n        streamTracks: stream.getTracks().length,\n        videoTracks: stream.getVideoTracks().length,\n        audioTracks: stream.getAudioTracks().length,\n        browser: {\n          isChrome,\n          isFirefox,\n          isSafari\n        }\n      });\n      const recorder = new window.MediaRecorder(stream, {\n        mimeType: selectedMimeType\n      });\n      setMediaRecorder(recorder);\n      setRecordingTime(0);\n      recorder.ondataavailable = e => {\n        console.log('Data available:', e.data.size, 'bytes, type:', e.data.type);\n        if (e.data.size > 0) {\n          chunksRef.current.push(e.data);\n          setChunks(prev => [...prev, e.data]);\n        } else {\n          console.warn('Received empty data chunk');\n        }\n      };\n      recorder.onerror = event => {\n        console.error('MediaRecorder error:', event.error);\n        console.error('Error details:', {\n          name: event.error.name,\n          message: event.error.message,\n          code: event.error.code\n        });\n        setStatus(`Recording error: ${event.error.name} - ${event.error.message}`);\n        setIsRecording(false);\n\n        // Clear intervals\n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        if (keepAliveInterval.current) {\n          clearInterval(keepAliveInterval.current);\n        }\n      };\n      recorder.onstart = () => {\n        console.log('MediaRecorder started successfully');\n        console.log('Recorder state:', recorder.state);\n        setStatus('Recording started successfully');\n      };\n      recorder.onpause = () => {\n        console.log('MediaRecorder paused');\n        setStatus('Recording paused');\n      };\n      recorder.onresume = () => {\n        console.log('MediaRecorder resumed');\n        setStatus('Recording resumed');\n      };\n      recorder.onstop = async () => {\n        console.log('Recording stopped. Total chunks:', chunksRef.current.length);\n        console.log('Total data size:', chunksRef.current.reduce((total, chunk) => total + chunk.size, 0), 'bytes');\n        console.log('Final recorder state:', recorder.state);\n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        if (chunksRef.current.length === 0) {\n          setStatus('Error: No recording data captured');\n          console.error('No chunks available for recording');\n          return;\n        }\n        const blob = new Blob(chunksRef.current, {\n          type: selectedMimeType\n        });\n        console.log('Blob created:', blob.size, 'bytes');\n        if (blob.size === 0) {\n          setStatus('Error: Recording file is empty');\n          console.error('Blob size is 0');\n          return;\n        }\n\n        // Upload to backend only - no automatic download\n        const formData = new FormData();\n        const filename = `recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.${selectedMimeType.includes('webm') ? 'webm' : 'mp4'}`;\n        formData.append('file', blob, filename);\n        try {\n          setStatus('Uploading recording...');\n          const response = await fetch(API_URL, {\n            method: 'POST',\n            body: formData\n          });\n          if (response.ok) {\n            const result = await response.json();\n            console.log('Upload successful:', result);\n            setStatus('Recording saved successfully! You can view it in the Playback page.');\n          } else {\n            const errorText = await response.text();\n            console.error('Upload failed:', errorText);\n            setStatus('Error saving recording to server');\n          }\n        } catch (err) {\n          setStatus('Error uploading recording');\n          console.error('Upload error:', err);\n        }\n      };\n\n      // Try with a larger timeslice to prevent browser limitations\n      // Some browsers have issues with very small timeslices\n      const timeslice = isSafari ? 10000 : 5000; // 10 seconds for Safari, 5 for others\n      recorder.start(timeslice);\n      setIsRecording(true);\n      setStatus('Recording...');\n\n      // Start recording timer\n      recordingTimer.current = setInterval(() => {\n        setRecordingTime(prev => prev + 1);\n      }, 1000);\n\n      // Monitor stream state\n      const streamStateCheck = setInterval(() => {\n        if (stream) {\n          const videoTrack = stream.getVideoTracks()[0];\n          const audioTrack = stream.getAudioTracks()[0];\n          if (videoTrack && videoTrack.readyState === 'ended') {\n            console.error('Video track ended unexpectedly');\n            setStatus('Video track ended - attempting to restart stream...');\n\n            // Try to restart the stream instead of stopping recording\n            restartStream();\n            return;\n          }\n          if (audioTrack && audioTrack.readyState === 'ended') {\n            console.error('Audio track ended unexpectedly');\n            setStatus('Audio track ended - attempting to restart stream...');\n\n            // Try to restart the stream instead of stopping recording\n            restartStream();\n            return;\n          }\n\n          // Check MediaRecorder state\n          if (recorder.state === 'inactive') {\n            console.error('MediaRecorder became inactive unexpectedly');\n            setStatus('MediaRecorder stopped unexpectedly');\n            setIsRecording(false);\n            clearInterval(streamStateCheck);\n          }\n\n          // Check for memory issues\n          if (performance.memory) {\n            const memoryUsage = performance.memory;\n            const memoryPercent = memoryUsage.usedJSHeapSize / memoryUsage.jsHeapSizeLimit * 100;\n            if (memoryPercent > 80) {\n              console.warn('High memory usage detected:', memoryPercent.toFixed(1) + '%');\n            }\n          }\n\n          // Log stream state every 5 seconds for more frequent monitoring\n          if (recordingTime % 5 === 0) {\n            console.log('Stream state check:', {\n              videoTrack: videoTrack ? {\n                readyState: videoTrack.readyState,\n                enabled: videoTrack.enabled\n              } : 'none',\n              audioTrack: audioTrack ? {\n                readyState: audioTrack.readyState,\n                enabled: audioTrack.enabled\n              } : 'none',\n              recorderState: recorder.state,\n              recordingTime: recordingTime,\n              chunksCount: chunksRef.current.length,\n              totalDataSize: chunksRef.current.reduce((total, chunk) => total + chunk.size, 0),\n              memoryUsage: performance.memory ? {\n                used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',\n                total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',\n                limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB'\n              } : 'Not available'\n            });\n          }\n\n          // Auto-restart if recording stops unexpectedly (but only once)\n          if (recordingTime > 10 && recorder.state === 'inactive' && !window.recordingRestarted) {\n            console.warn('Recording stopped unexpectedly, attempting restart...');\n            window.recordingRestarted = true;\n            setStatus('Recording stopped unexpectedly, attempting restart...');\n\n            // Stop current recording\n            if (recorder.state !== 'inactive') {\n              recorder.stop();\n            }\n\n            // Clear intervals\n            clearInterval(streamStateCheck);\n            if (recordingTimer.current) {\n              clearInterval(recordingTimer.current);\n            }\n\n            // Restart recording after a short delay\n            setTimeout(() => {\n              startRecording();\n            }, 1000);\n          }\n        }\n      }, 1000);\n\n      // Store the interval reference for cleanup\n      streamStateCheck.current = streamStateCheck;\n\n      // Add track event listeners to detect when tracks end\n      stream.getTracks().forEach(track => {\n        track.onended = () => {\n          console.warn(`${track.kind} track ended:`, track.id);\n          setStatus(`${track.kind} track ended - attempting to restart...`);\n          restartStream();\n        };\n        track.onmute = () => {\n          console.warn(`${track.kind} track muted:`, track.id);\n        };\n        track.onunmute = () => {\n          console.log(`${track.kind} track unmuted:`, track.id);\n        };\n      });\n\n      // Keep-alive mechanism to prevent track suspension\n      const keepAliveInterval = setInterval(() => {\n        if (stream && isRecording) {\n          // Ensure video element is playing to keep tracks active\n          if (videoRef.current && videoRef.current.paused) {\n            videoRef.current.play().catch(e => console.log('Keep-alive video play error:', e));\n          }\n\n          // Log track health\n          stream.getTracks().forEach(track => {\n            if (track.readyState === 'ended') {\n              console.warn(`Track ${track.kind} ended during keep-alive check`);\n            }\n          });\n        }\n      }, 2000); // Check every 2 seconds\n\n      // Store keep-alive interval for cleanup\n      keepAliveInterval.current = keepAliveInterval;\n    } catch (error) {\n      setStatus('Error starting recording');\n      console.error('Recording error:', error);\n    }\n  };\n\n  // Function to restart the stream when tracks end\n  const restartStream = async () => {\n    if (!isRecording) return;\n    try {\n      setStatus('Restarting stream...');\n      console.log('Attempting to restart stream...');\n\n      // Stop current recorder\n      if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n        mediaRecorder.stop();\n      }\n\n      // Stop current stream\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n\n      // Get new stream\n      const constraints = isAudioOnly ? {\n        audio: QUALITY_PRESETS.audioOnly.audio\n      } : {\n        video: {\n          deviceId: cameras[currentCameraIndex] ? {\n            exact: cameras[currentCameraIndex].deviceId\n          } : undefined,\n          ...QUALITY_PRESETS[currentQuality].video\n        },\n        audio: QUALITY_PRESETS[currentQuality].audio\n      };\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n\n      // Restart recording with new stream\n      setTimeout(() => {\n        startRecording();\n      }, 500);\n    } catch (error) {\n      console.error('Error restarting stream:', error);\n      setStatus('Failed to restart stream - stopping recording');\n      setIsRecording(false);\n    }\n  };\n\n  // Stop recording\n  const stopRecording = () => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      setStatus('Stopping recording...');\n    }\n  };\n\n  // Initialize camera access\n  useEffect(() => {\n    const initCamera = async () => {\n      try {\n        setStatus('Accessing camera...');\n        await getCameras();\n\n        // Start with medium quality\n        const initialStream = await navigator.mediaDevices.getUserMedia({\n          video: QUALITY_PRESETS.medium.video,\n          audio: QUALITY_PRESETS.medium.audio\n        });\n        setStream(initialStream);\n        if (videoRef.current) {\n          videoRef.current.srcObject = initialStream;\n          // Keep video element active to prevent track ending\n          videoRef.current.play().catch(e => console.log('Video play error:', e));\n        }\n        setStatus('Camera ready');\n      } catch (err) {\n        setStatus('Error accessing camera/microphone');\n        console.error('Camera access error:', err);\n      }\n    };\n    initCamera();\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (networkCheckInterval.current) {\n        clearInterval(networkCheckInterval.current);\n      }\n      if (recordingTimer.current) {\n        clearInterval(recordingTimer.current);\n      }\n      if (streamStateCheck.current) {\n        clearInterval(streamStateCheck.current);\n      }\n    };\n  }, []);\n\n  // Format recording time\n  const formatTime = seconds => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"max-w-4xl mx-auto mt-10 bg-white rounded-lg shadow p-6\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      className: \"text-2xl font-bold mb-4 text-blue-700\",\n      children: \"Record Video\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 634,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-4 p-3 bg-gray-100 rounded\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-700\",\n        children: [\"Status: \", status]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 637,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-700\",\n        children: [\"Quality: \", currentQuality, \" \", isAudioOnly && '(Audio Only)']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 638,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-700\",\n        children: [\"Network: \", networkQuality]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 639,\n        columnNumber: 9\n      }, this), isRecording && /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-red-600 font-semibold\",\n        children: [\"Recording: \", formatTime(recordingTime)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 641,\n        columnNumber: 11\n      }, this), cameras.length > 1 && /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-xs text-gray-500 mt-1\",\n        children: [\"Available cameras: \", cameras.length, \" | Current: \", ((_cameras$currentCamer = cameras[currentCameraIndex]) === null || _cameras$currentCamer === void 0 ? void 0 : _cameras$currentCamer.label) || 'Camera ' + (currentCameraIndex + 1)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 644,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 636,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"flex gap-4 mb-6 flex-wrap\",\n      children: [!isRecording ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: startRecording,\n        className: \"bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\",\n        children: \"Start Recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 652,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: stopRecording,\n        className: \"bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\",\n        children: \"Stop Recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 659,\n        columnNumber: 11\n      }, this), cameras.length > 1 && /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: switchCamera,\n        disabled: isRecording,\n        className: `px-4 py-3 rounded-lg shadow-lg font-semibold ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-yellow-600 hover:bg-yellow-700 text-white'}`,\n        children: \"Switch Camera\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 668,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex gap-2\",\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('high'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'high' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"High\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 683,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('medium'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'medium' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"Medium\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 696,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('low'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'low' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"Low\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 709,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('audioOnly'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'audioOnly' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"Audio Only\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 722,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 682,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 650,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"relative\",\n      children: [/*#__PURE__*/_jsxDEV(\"video\", {\n        ref: videoRef,\n        autoPlay: true,\n        playsInline: true,\n        muted: true,\n        className: \"rounded-lg shadow-lg border-2 border-blue-200 w-full h-96 bg-black\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 739,\n        columnNumber: 9\n      }, this), isAudioOnly && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"absolute top-4 left-4 p-2 bg-yellow-100 rounded text-center\",\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"text-yellow-800 text-sm font-semibold\",\n          children: \"Audio Only Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 749,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"text-yellow-700 text-xs\",\n          children: \"Poor Network Detected\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 750,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 748,\n        columnNumber: 11\n      }, this), isRecording && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"absolute top-4 right-4 p-2 bg-red-600 rounded text-white\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"flex items-center gap-2\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"w-3 h-3 bg-white rounded-full animate-pulse\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 757,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"font-semibold\",\n            children: \"REC\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 758,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 756,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 755,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 738,\n      columnNumber: 7\n    }, this), isRecording && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-4 p-3 bg-red-100 rounded\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-red-700 text-sm\",\n        children: [\"\\uD83D\\uDD34 Recording in progress... \", formatTime(recordingTime)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 766,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 765,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-6 p-4 bg-blue-50 rounded\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        className: \"font-semibold text-blue-800 mb-2\",\n        children: \"Adaptive Quality Features:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 771,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        className: \"text-sm text-blue-700 space-y-1\",\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Automatic quality adjustment based on network conditions\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 773,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Fallback to audio-only recording in poor network\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 774,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Manual quality control for optimal recording\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 775,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Real-time network quality monitoring\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 776,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Automatic camera switching support\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 777,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 772,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 770,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 633,\n    columnNumber: 5\n  }, this);\n};\n_s(Record, \"X5tOwHK39lqbmvJZpp5fYPcwu78=\");\n_c = Record;\nexport default Record;\nvar _c;\n$RefreshReg$(_c, \"Record\");","map":{"version":3,"names":["React","useRef","useState","useEffect","toast","jsxDEV","_jsxDEV","API_URL","QUALITY_PRESETS","high","video","width","height","frameRate","bitrate","audio","sampleRate","channelCount","medium","low","audioOnly","Record","_s","_cameras$currentCamer","isRecording","setIsRecording","mediaRecorder","setMediaRecorder","chunks","setChunks","stream","setStream","cameras","setCameras","currentCameraIndex","setCurrentCameraIndex","currentQuality","setCurrentQuality","isAudioOnly","setIsAudioOnly","networkQuality","setNetworkQuality","recordingTime","setRecordingTime","status","setStatus","videoRef","recordingTimer","networkCheckInterval","streamStateCheck","keepAliveInterval","chunksRef","getCameras","devices","navigator","mediaDevices","enumerateDevices","videoDevices","filter","device","kind","err","console","error","assessNetworkQuality","startTime","performance","now","response","fetch","method","cache","endTime","latency","newQuality","newAudioOnly","ok","adjustRecordingQuality","toFixed","quality","getTracks","forEach","track","stop","constraints","deviceId","exact","undefined","newStream","getUserMedia","current","srcObject","message","setQuality","switchCamera","length","newIndex","startRecording","window","recordingRestarted","setInterval","userAgent","isChrome","includes","isFirefox","isSafari","log","mimeTypes","selectedMimeType","mimeType","MediaRecorder","isTypeSupported","Error","streamTracks","videoTracks","getVideoTracks","audioTracks","getAudioTracks","browser","recorder","ondataavailable","e","data","size","type","push","prev","warn","onerror","event","name","code","clearInterval","onstart","state","onpause","onresume","onstop","reduce","total","chunk","blob","Blob","formData","FormData","filename","Date","toISOString","slice","replace","append","body","result","json","errorText","text","timeslice","start","videoTrack","audioTrack","readyState","restartStream","memory","memoryUsage","memoryPercent","usedJSHeapSize","jsHeapSizeLimit","enabled","recorderState","chunksCount","totalDataSize","used","Math","round","totalJSHeapSize","limit","setTimeout","onended","id","onmute","onunmute","paused","play","catch","stopRecording","initCamera","initialStream","formatTime","seconds","mins","floor","secs","toString","padStart","className","children","fileName","_jsxFileName","lineNumber","columnNumber","label","onClick","disabled","ref","autoPlay","playsInline","muted","_c","$RefreshReg$"],"sources":["/Users/dhruva_kumar/Work Space/final project/client/src/pages/Record.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport toast from 'react-hot-toast';\n\nconst API_URL = 'http://192.168.98.141:5001/api/recordings';\n\n// Quality presets for adaptive recording\nconst QUALITY_PRESETS = {\n  high: {\n    video: { width: 1280, height: 720, frameRate: 30, bitrate: 2500000 },\n    audio: { sampleRate: 48000, channelCount: 2, bitrate: 128000 }\n  },\n  medium: {\n    video: { width: 854, height: 480, frameRate: 25, bitrate: 1000000 },\n    audio: { sampleRate: 44100, channelCount: 2, bitrate: 96000 }\n  },\n  low: {\n    video: { width: 640, height: 360, frameRate: 20, bitrate: 500000 },\n    audio: { sampleRate: 22050, channelCount: 1, bitrate: 64000 }\n  },\n  audioOnly: {\n    video: false,\n    audio: { sampleRate: 22050, channelCount: 1, bitrate: 32000 }\n  }\n};\n\nconst Record = () => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [chunks, setChunks] = useState([]);\n  const [stream, setStream] = useState(null);\n  const [cameras, setCameras] = useState([]);\n  const [currentCameraIndex, setCurrentCameraIndex] = useState(0);\n  const [currentQuality, setCurrentQuality] = useState('medium');\n  const [isAudioOnly, setIsAudioOnly] = useState(false);\n  const [networkQuality, setNetworkQuality] = useState('unknown');\n  const [recordingTime, setRecordingTime] = useState(0);\n  const [status, setStatus] = useState('Ready to record');\n\n  const videoRef = useRef();\n  const recordingTimer = useRef(null);\n  const networkCheckInterval = useRef(null);\n  const streamStateCheck = useRef(null);\n  const keepAliveInterval = useRef(null);\n  const chunksRef = useRef([]); // Use ref to store chunks\n\n  // Get available cameras\n  const getCameras = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      setCameras(videoDevices);\n      return videoDevices;\n    } catch (err) {\n      console.error('Error getting cameras:', err);\n      return [];\n    }\n  };\n\n  // Assess network quality for recording\n  const assessNetworkQuality = async () => {\n    try {\n      // Simple network quality assessment for recording\n      const startTime = performance.now();\n      const response = await fetch(API_URL, { \n        method: 'HEAD',\n        cache: 'no-cache'\n      });\n      const endTime = performance.now();\n      const latency = endTime - startTime;\n\n      let newQuality = currentQuality;\n      let newAudioOnly = isAudioOnly;\n\n      if (latency > 1000 || !response.ok) {\n        // Poor network - switch to audio only\n        newQuality = 'audioOnly';\n        newAudioOnly = true;\n        setNetworkQuality('poor');\n      } else if (latency > 500) {\n        // Medium network - use low quality\n        newQuality = 'low';\n        newAudioOnly = false;\n        setNetworkQuality('medium');\n      } else if (latency > 200) {\n        // Good network - use medium quality\n        newQuality = 'medium';\n        newAudioOnly = false;\n        setNetworkQuality('good');\n      } else {\n        // Excellent network - use high quality\n        newQuality = 'high';\n        newAudioOnly = false;\n        setNetworkQuality('excellent');\n      }\n\n      // Apply quality changes if needed\n      if (newQuality !== currentQuality || newAudioOnly !== isAudioOnly) {\n        await adjustRecordingQuality(newQuality, newAudioOnly);\n      }\n\n      setStatus(`Network: ${networkQuality} (${latency.toFixed(0)}ms latency)`);\n    } catch (error) {\n      console.error('Error assessing network quality:', error);\n      // If network check fails, assume poor network and switch to audio only\n      if (currentQuality !== 'audioOnly') {\n        await adjustRecordingQuality('audioOnly', true);\n      }\n    }\n  };\n\n  // Adjust recording quality based on network conditions\n  const adjustRecordingQuality = async (quality, audioOnly = false) => {\n    if (isRecording) {\n      setStatus('Cannot adjust quality while recording');\n      return;\n    }\n\n    try {\n      setStatus(`Adjusting quality to: ${quality}${audioOnly ? ' (audio only)' : ''}`);\n      \n      // Stop current stream if exists\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      \n      // Get new stream with adjusted quality\n      const constraints = audioOnly ? \n        { audio: QUALITY_PRESETS.audioOnly.audio } :\n        { \n          video: { \n            deviceId: cameras[currentCameraIndex] ? { exact: cameras[currentCameraIndex].deviceId } : undefined,\n            ...QUALITY_PRESETS[quality].video \n          },\n          audio: QUALITY_PRESETS[quality].audio\n        };\n\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n\n      setCurrentQuality(quality);\n      setIsAudioOnly(audioOnly);\n      setStatus(`Quality adjusted to ${quality}`);\n    } catch (error) {\n      console.error('Error adjusting recording quality:', error);\n      setStatus(`Error adjusting quality: ${error.message}`);\n    }\n  };\n\n  // Manual quality adjustment\n  const setQuality = async (quality) => {\n    await adjustRecordingQuality(quality, quality === 'audioOnly');\n  };\n\n  // Switch camera\n  const switchCamera = async () => {\n    if (cameras.length < 2) {\n      setStatus('Only one camera available');\n      return;\n    }\n\n    if (isRecording) {\n      setStatus('Cannot switch camera while recording');\n      return;\n    }\n\n    const newIndex = (currentCameraIndex + 1) % cameras.length;\n    setCurrentCameraIndex(newIndex);\n    \n    if (stream) {\n      stream.getTracks().forEach(track => track.stop());\n    }\n\n    try {\n      setStatus('Switching camera...');\n      const constraints = isAudioOnly ? \n        { audio: QUALITY_PRESETS.audioOnly.audio } :\n        { \n          video: { \n            deviceId: { exact: cameras[newIndex].deviceId }, \n            ...QUALITY_PRESETS[currentQuality].video \n          },\n          audio: QUALITY_PRESETS[currentQuality].audio\n        };\n\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      videoRef.current.srcObject = newStream;\n      setStatus('Camera switched!');\n    } catch (err) {\n      setStatus('Error switching camera');\n      console.error('Camera switch error:', err);\n    }\n  };\n\n  // Start recording\n  const startRecording = async () => {\n    if (!stream) {\n      setStatus('No media stream available');\n      return;\n    }\n\n    try {\n      setStatus('Starting recording...');\n      \n      // Reset restart flag for new recording session\n      window.recordingRestarted = false;\n      \n      // Start network quality monitoring\n      networkCheckInterval.current = setInterval(assessNetworkQuality, 10000);\n      \n      // Clear previous chunks\n      chunksRef.current = [];\n      setChunks([]);\n      \n      // Detect browser for potential limitations\n      const userAgent = navigator.userAgent;\n      const isChrome = userAgent.includes('Chrome');\n      const isFirefox = userAgent.includes('Firefox');\n      const isSafari = userAgent.includes('Safari') && !userAgent.includes('Chrome');\n      \n      console.log('Browser detection:', { isChrome, isFirefox, isSafari, userAgent });\n      \n      // Check for supported MIME types with browser-specific preferences\n      const mimeTypes = isChrome ? [\n        'video/webm;codecs=vp8,opus',\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=vp8',\n        'video/webm'\n      ] : isFirefox ? [\n        'video/webm;codecs=vp8,opus',\n        'video/webm;codecs=vp8',\n        'video/webm'\n      ] : isSafari ? [\n        'video/mp4',\n        'video/webm'\n      ] : [\n        'video/webm;codecs=vp8,opus',\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=vp8',\n        'video/webm',\n        'video/mp4'\n      ];\n      \n      let selectedMimeType = null;\n      for (const mimeType of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(mimeType)) {\n          selectedMimeType = mimeType;\n          console.log('Using MIME type:', mimeType);\n          break;\n        }\n      }\n      \n      if (!selectedMimeType) {\n        throw new Error('No supported video MIME type found');\n      }\n      \n      console.log('Starting MediaRecorder with:', {\n        mimeType: selectedMimeType,\n        streamTracks: stream.getTracks().length,\n        videoTracks: stream.getVideoTracks().length,\n        audioTracks: stream.getAudioTracks().length,\n        browser: { isChrome, isFirefox, isSafari }\n      });\n      \n      const recorder = new window.MediaRecorder(stream, {\n        mimeType: selectedMimeType\n      });\n      \n      setMediaRecorder(recorder);\n      setRecordingTime(0);\n      \n      recorder.ondataavailable = (e) => {\n        console.log('Data available:', e.data.size, 'bytes, type:', e.data.type);\n        if (e.data.size > 0) {\n          chunksRef.current.push(e.data);\n          setChunks(prev => [...prev, e.data]);\n        } else {\n          console.warn('Received empty data chunk');\n        }\n      };\n      \n      recorder.onerror = (event) => {\n        console.error('MediaRecorder error:', event.error);\n        console.error('Error details:', {\n          name: event.error.name,\n          message: event.error.message,\n          code: event.error.code\n        });\n        setStatus(`Recording error: ${event.error.name} - ${event.error.message}`);\n        setIsRecording(false);\n        \n        // Clear intervals\n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        if (keepAliveInterval.current) {\n          clearInterval(keepAliveInterval.current);\n        }\n      };\n      \n      recorder.onstart = () => {\n        console.log('MediaRecorder started successfully');\n        console.log('Recorder state:', recorder.state);\n        setStatus('Recording started successfully');\n      };\n      \n      recorder.onpause = () => {\n        console.log('MediaRecorder paused');\n        setStatus('Recording paused');\n      };\n      \n      recorder.onresume = () => {\n        console.log('MediaRecorder resumed');\n        setStatus('Recording resumed');\n      };\n      \n      recorder.onstop = async () => {\n        console.log('Recording stopped. Total chunks:', chunksRef.current.length);\n        console.log('Total data size:', chunksRef.current.reduce((total, chunk) => total + chunk.size, 0), 'bytes');\n        console.log('Final recorder state:', recorder.state);\n        \n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        \n        if (chunksRef.current.length === 0) {\n          setStatus('Error: No recording data captured');\n          console.error('No chunks available for recording');\n          return;\n        }\n        \n        const blob = new Blob(chunksRef.current, { type: selectedMimeType });\n        console.log('Blob created:', blob.size, 'bytes');\n        \n        if (blob.size === 0) {\n          setStatus('Error: Recording file is empty');\n          console.error('Blob size is 0');\n          return;\n        }\n        \n        // Upload to backend only - no automatic download\n        const formData = new FormData();\n        const filename = `recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.${selectedMimeType.includes('webm') ? 'webm' : 'mp4'}`;\n        formData.append('file', blob, filename);\n        \n        try {\n          setStatus('Uploading recording...');\n          const response = await fetch(API_URL, { \n            method: 'POST', \n            body: formData \n          });\n          \n          if (response.ok) {\n            const result = await response.json();\n            console.log('Upload successful:', result);\n            setStatus('Recording saved successfully! You can view it in the Playback page.');\n          } else {\n            const errorText = await response.text();\n            console.error('Upload failed:', errorText);\n            setStatus('Error saving recording to server');\n          }\n        } catch (err) {\n          setStatus('Error uploading recording');\n          console.error('Upload error:', err);\n        }\n      };\n      \n      // Try with a larger timeslice to prevent browser limitations\n      // Some browsers have issues with very small timeslices\n      const timeslice = isSafari ? 10000 : 5000; // 10 seconds for Safari, 5 for others\n      recorder.start(timeslice);\n      setIsRecording(true);\n      setStatus('Recording...');\n      \n      // Start recording timer\n      recordingTimer.current = setInterval(() => {\n        setRecordingTime(prev => prev + 1);\n      }, 1000);\n      \n      // Monitor stream state\n      const streamStateCheck = setInterval(() => {\n        if (stream) {\n          const videoTrack = stream.getVideoTracks()[0];\n          const audioTrack = stream.getAudioTracks()[0];\n          \n          if (videoTrack && videoTrack.readyState === 'ended') {\n            console.error('Video track ended unexpectedly');\n            setStatus('Video track ended - attempting to restart stream...');\n            \n            // Try to restart the stream instead of stopping recording\n            restartStream();\n            return;\n          }\n          \n          if (audioTrack && audioTrack.readyState === 'ended') {\n            console.error('Audio track ended unexpectedly');\n            setStatus('Audio track ended - attempting to restart stream...');\n            \n            // Try to restart the stream instead of stopping recording\n            restartStream();\n            return;\n          }\n          \n          // Check MediaRecorder state\n          if (recorder.state === 'inactive') {\n            console.error('MediaRecorder became inactive unexpectedly');\n            setStatus('MediaRecorder stopped unexpectedly');\n            setIsRecording(false);\n            clearInterval(streamStateCheck);\n          }\n          \n          // Check for memory issues\n          if (performance.memory) {\n            const memoryUsage = performance.memory;\n            const memoryPercent = (memoryUsage.usedJSHeapSize / memoryUsage.jsHeapSizeLimit) * 100;\n            if (memoryPercent > 80) {\n              console.warn('High memory usage detected:', memoryPercent.toFixed(1) + '%');\n            }\n          }\n          \n          // Log stream state every 5 seconds for more frequent monitoring\n          if (recordingTime % 5 === 0) {\n            console.log('Stream state check:', {\n              videoTrack: videoTrack ? { readyState: videoTrack.readyState, enabled: videoTrack.enabled } : 'none',\n              audioTrack: audioTrack ? { readyState: audioTrack.readyState, enabled: audioTrack.enabled } : 'none',\n              recorderState: recorder.state,\n              recordingTime: recordingTime,\n              chunksCount: chunksRef.current.length,\n              totalDataSize: chunksRef.current.reduce((total, chunk) => total + chunk.size, 0),\n              memoryUsage: performance.memory ? {\n                used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',\n                total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',\n                limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB'\n              } : 'Not available'\n            });\n          }\n          \n          // Auto-restart if recording stops unexpectedly (but only once)\n          if (recordingTime > 10 && recorder.state === 'inactive' && !window.recordingRestarted) {\n            console.warn('Recording stopped unexpectedly, attempting restart...');\n            window.recordingRestarted = true;\n            setStatus('Recording stopped unexpectedly, attempting restart...');\n            \n            // Stop current recording\n            if (recorder.state !== 'inactive') {\n              recorder.stop();\n            }\n            \n            // Clear intervals\n            clearInterval(streamStateCheck);\n            if (recordingTimer.current) {\n              clearInterval(recordingTimer.current);\n            }\n            \n            // Restart recording after a short delay\n            setTimeout(() => {\n              startRecording();\n            }, 1000);\n          }\n        }\n      }, 1000);\n      \n      // Store the interval reference for cleanup\n      streamStateCheck.current = streamStateCheck;\n      \n      // Add track event listeners to detect when tracks end\n      stream.getTracks().forEach(track => {\n        track.onended = () => {\n          console.warn(`${track.kind} track ended:`, track.id);\n          setStatus(`${track.kind} track ended - attempting to restart...`);\n          restartStream();\n        };\n        \n        track.onmute = () => {\n          console.warn(`${track.kind} track muted:`, track.id);\n        };\n        \n        track.onunmute = () => {\n          console.log(`${track.kind} track unmuted:`, track.id);\n        };\n      });\n      \n      // Keep-alive mechanism to prevent track suspension\n      const keepAliveInterval = setInterval(() => {\n        if (stream && isRecording) {\n          // Ensure video element is playing to keep tracks active\n          if (videoRef.current && videoRef.current.paused) {\n            videoRef.current.play().catch(e => console.log('Keep-alive video play error:', e));\n          }\n          \n          // Log track health\n          stream.getTracks().forEach(track => {\n            if (track.readyState === 'ended') {\n              console.warn(`Track ${track.kind} ended during keep-alive check`);\n            }\n          });\n        }\n      }, 2000); // Check every 2 seconds\n      \n      // Store keep-alive interval for cleanup\n      keepAliveInterval.current = keepAliveInterval;\n      \n    } catch (error) {\n      setStatus('Error starting recording');\n      console.error('Recording error:', error);\n    }\n  };\n\n  // Function to restart the stream when tracks end\n  const restartStream = async () => {\n    if (!isRecording) return;\n    \n    try {\n      setStatus('Restarting stream...');\n      console.log('Attempting to restart stream...');\n      \n      // Stop current recorder\n      if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n        mediaRecorder.stop();\n      }\n      \n      // Stop current stream\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      \n      // Get new stream\n      const constraints = isAudioOnly ? \n        { audio: QUALITY_PRESETS.audioOnly.audio } :\n        { \n          video: { \n            deviceId: cameras[currentCameraIndex] ? { exact: cameras[currentCameraIndex].deviceId } : undefined,\n            ...QUALITY_PRESETS[currentQuality].video \n          },\n          audio: QUALITY_PRESETS[currentQuality].audio\n        };\n\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      \n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n      \n      // Restart recording with new stream\n      setTimeout(() => {\n        startRecording();\n      }, 500);\n      \n    } catch (error) {\n      console.error('Error restarting stream:', error);\n      setStatus('Failed to restart stream - stopping recording');\n      setIsRecording(false);\n    }\n  };\n\n  // Stop recording\n  const stopRecording = () => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      setStatus('Stopping recording...');\n    }\n  };\n\n  // Initialize camera access\n  useEffect(() => {\n    const initCamera = async () => {\n      try {\n        setStatus('Accessing camera...');\n        await getCameras();\n        \n        // Start with medium quality\n        const initialStream = await navigator.mediaDevices.getUserMedia({\n          video: QUALITY_PRESETS.medium.video,\n          audio: QUALITY_PRESETS.medium.audio\n        });\n        \n        setStream(initialStream);\n        if (videoRef.current) {\n          videoRef.current.srcObject = initialStream;\n          // Keep video element active to prevent track ending\n          videoRef.current.play().catch(e => console.log('Video play error:', e));\n        }\n        setStatus('Camera ready');\n      } catch (err) {\n        setStatus('Error accessing camera/microphone');\n        console.error('Camera access error:', err);\n      }\n    };\n\n    initCamera();\n\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (networkCheckInterval.current) {\n        clearInterval(networkCheckInterval.current);\n      }\n      if (recordingTimer.current) {\n        clearInterval(recordingTimer.current);\n      }\n      if (streamStateCheck.current) {\n        clearInterval(streamStateCheck.current);\n      }\n    };\n  }, []);\n\n  // Format recording time\n  const formatTime = (seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  return (\n    <div className=\"max-w-4xl mx-auto mt-10 bg-white rounded-lg shadow p-6\">\n      <h2 className=\"text-2xl font-bold mb-4 text-blue-700\">Record Video</h2>\n      \n      <div className=\"mb-4 p-3 bg-gray-100 rounded\">\n        <p className=\"text-sm text-gray-700\">Status: {status}</p>\n        <p className=\"text-sm text-gray-700\">Quality: {currentQuality} {isAudioOnly && '(Audio Only)'}</p>\n        <p className=\"text-sm text-gray-700\">Network: {networkQuality}</p>\n        {isRecording && (\n          <p className=\"text-sm text-red-600 font-semibold\">Recording: {formatTime(recordingTime)}</p>\n        )}\n        {cameras.length > 1 && (\n          <p className=\"text-xs text-gray-500 mt-1\">\n            Available cameras: {cameras.length} | Current: {cameras[currentCameraIndex]?.label || 'Camera ' + (currentCameraIndex + 1)}\n          </p>\n        )}\n      </div>\n\n      <div className=\"flex gap-4 mb-6 flex-wrap\">\n        {!isRecording ? (\n          <button\n            onClick={startRecording}\n            className=\"bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\"\n          >\n            Start Recording\n          </button>\n        ) : (\n          <button\n            onClick={stopRecording}\n            className=\"bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\"\n          >\n            Stop Recording\n          </button>\n        )}\n        \n        {cameras.length > 1 && (\n          <button\n            onClick={switchCamera}\n            disabled={isRecording}\n            className={`px-4 py-3 rounded-lg shadow-lg font-semibold ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : 'bg-yellow-600 hover:bg-yellow-700 text-white'\n            }`}\n          >\n            Switch Camera\n          </button>\n        )}\n        \n        {/* Manual Quality Controls */}\n        <div className=\"flex gap-2\">\n          <button\n            onClick={() => setQuality('high')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'high' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            High\n          </button>\n          <button\n            onClick={() => setQuality('medium')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'medium' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            Medium\n          </button>\n          <button\n            onClick={() => setQuality('low')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'low' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            Low\n          </button>\n          <button\n            onClick={() => setQuality('audioOnly')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'audioOnly' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            Audio Only\n          </button>\n        </div>\n      </div>\n\n      <div className=\"relative\">\n        <video\n          ref={videoRef}\n          autoPlay\n          playsInline\n          muted\n          className=\"rounded-lg shadow-lg border-2 border-blue-200 w-full h-96 bg-black\"\n        />\n        \n        {isAudioOnly && (\n          <div className=\"absolute top-4 left-4 p-2 bg-yellow-100 rounded text-center\">\n            <p className=\"text-yellow-800 text-sm font-semibold\">Audio Only Mode</p>\n            <p className=\"text-yellow-700 text-xs\">Poor Network Detected</p>\n          </div>\n        )}\n        \n        {isRecording && (\n          <div className=\"absolute top-4 right-4 p-2 bg-red-600 rounded text-white\">\n            <div className=\"flex items-center gap-2\">\n              <div className=\"w-3 h-3 bg-white rounded-full animate-pulse\"></div>\n              <span className=\"font-semibold\">REC</span>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {isRecording && (\n        <div className=\"mt-4 p-3 bg-red-100 rounded\">\n          <p className=\"text-red-700 text-sm\"> Recording in progress... {formatTime(recordingTime)}</p>\n        </div>\n      )}\n\n      <div className=\"mt-6 p-4 bg-blue-50 rounded\">\n        <h3 className=\"font-semibold text-blue-800 mb-2\">Adaptive Quality Features:</h3>\n        <ul className=\"text-sm text-blue-700 space-y-1\">\n          <li> Automatic quality adjustment based on network conditions</li>\n          <li> Fallback to audio-only recording in poor network</li>\n          <li> Manual quality control for optimal recording</li>\n          <li> Real-time network quality monitoring</li>\n          <li> Automatic camera switching support</li>\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport default Record; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}