{"ast":null,"code":"var _jsxFileName = \"/Users/dhruva_kumar/Work Space/final project/client/src/pages/Record.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport toast from 'react-hot-toast';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_URL = 'http://10.28.159.141:5001/api/recordings'; //http://10.28.159.141:5001/\n\n// Quality presets for adaptive recording\nconst QUALITY_PRESETS = {\n  high: {\n    video: {\n      width: 1280,\n      height: 720,\n      frameRate: 30,\n      bitrate: 2500000\n    },\n    audio: {\n      sampleRate: 48000,\n      channelCount: 2,\n      bitrate: 128000\n    }\n  },\n  medium: {\n    video: {\n      width: 854,\n      height: 480,\n      frameRate: 25,\n      bitrate: 1000000\n    },\n    audio: {\n      sampleRate: 44100,\n      channelCount: 2,\n      bitrate: 96000\n    }\n  },\n  low: {\n    video: {\n      width: 640,\n      height: 360,\n      frameRate: 20,\n      bitrate: 500000\n    },\n    audio: {\n      sampleRate: 22050,\n      channelCount: 1,\n      bitrate: 64000\n    }\n  },\n  audioOnly: {\n    video: false,\n    audio: {\n      sampleRate: 22050,\n      channelCount: 1,\n      bitrate: 32000\n    }\n  }\n};\nconst Record = () => {\n  _s();\n  var _cameras$currentCamer;\n  const [isRecording, setIsRecording] = useState(false);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [chunks, setChunks] = useState([]);\n  const [stream, setStream] = useState(null);\n  const [cameras, setCameras] = useState([]);\n  const [currentCameraIndex, setCurrentCameraIndex] = useState(0);\n  const [currentQuality, setCurrentQuality] = useState('medium');\n  const [isAudioOnly, setIsAudioOnly] = useState(false);\n  const [networkQuality, setNetworkQuality] = useState('unknown');\n  const [recordingTime, setRecordingTime] = useState(0);\n  const [status, setStatus] = useState('Ready to record');\n  const videoRef = useRef();\n  const recordingTimer = useRef(null);\n  const networkCheckInterval = useRef(null);\n  const streamStateCheck = useRef(null);\n  const keepAliveInterval = useRef(null);\n  const chunkRequestInterval = useRef(null);\n  const chunksRef = useRef([]); // Use ref to store chunks\n\n  // Get available cameras\n  const getCameras = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      setCameras(videoDevices);\n      return videoDevices;\n    } catch (err) {\n      console.error('Error getting cameras:', err);\n      return [];\n    }\n  };\n\n  // Assess network quality for recording\n  const assessNetworkQuality = async () => {\n    try {\n      // Simple network quality assessment for recording\n      const startTime = performance.now();\n      const response = await fetch(API_URL, {\n        method: 'HEAD',\n        cache: 'no-cache'\n      });\n      const endTime = performance.now();\n      const latency = endTime - startTime;\n      let newQuality = currentQuality;\n      let newAudioOnly = isAudioOnly;\n      if (latency > 1000 || !response.ok) {\n        // Poor network - switch to audio only\n        newQuality = 'audioOnly';\n        newAudioOnly = true;\n        setNetworkQuality('poor');\n      } else if (latency > 500) {\n        // Medium network - use low quality\n        newQuality = 'low';\n        newAudioOnly = false;\n        setNetworkQuality('medium');\n      } else if (latency > 200) {\n        // Good network - use medium quality\n        newQuality = 'medium';\n        newAudioOnly = false;\n        setNetworkQuality('good');\n      } else {\n        // Excellent network - use high quality\n        newQuality = 'high';\n        newAudioOnly = false;\n        setNetworkQuality('excellent');\n      }\n\n      // Apply quality changes if needed\n      if (newQuality !== currentQuality || newAudioOnly !== isAudioOnly) {\n        await adjustRecordingQuality(newQuality, newAudioOnly);\n      }\n      setStatus(`Network: ${networkQuality} (${latency.toFixed(0)}ms latency)`);\n    } catch (error) {\n      console.error('Error assessing network quality:', error);\n      // If network check fails, assume poor network and switch to audio only\n      if (currentQuality !== 'audioOnly') {\n        await adjustRecordingQuality('audioOnly', true);\n      }\n    }\n  };\n\n  // Adjust recording quality based on network conditions\n  const adjustRecordingQuality = async (quality, audioOnly = false) => {\n    if (isRecording) {\n      setStatus('Cannot adjust quality while recording');\n      return;\n    }\n    try {\n      setStatus(`Adjusting quality to: ${quality}${audioOnly ? ' (audio only)' : ''}`);\n\n      // Stop current stream if exists\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n\n      // Get new stream with adjusted quality\n      const constraints = audioOnly ? {\n        audio: QUALITY_PRESETS.audioOnly.audio\n      } : {\n        video: {\n          deviceId: cameras[currentCameraIndex] ? {\n            exact: cameras[currentCameraIndex].deviceId\n          } : undefined,\n          ...QUALITY_PRESETS[quality].video\n        },\n        audio: QUALITY_PRESETS[quality].audio\n      };\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n      setCurrentQuality(quality);\n      setIsAudioOnly(audioOnly);\n      setStatus(`Quality adjusted to ${quality}`);\n    } catch (error) {\n      console.error('Error adjusting recording quality:', error);\n      setStatus(`Error adjusting quality: ${error.message}`);\n    }\n  };\n\n  // Manual quality adjustment\n  const setQuality = async quality => {\n    await adjustRecordingQuality(quality, quality === 'audioOnly');\n  };\n\n  // Switch camera\n  const switchCamera = async () => {\n    if (cameras.length < 2) {\n      setStatus('Only one camera available');\n      return;\n    }\n    if (isRecording) {\n      setStatus('Cannot switch camera while recording');\n      return;\n    }\n    const newIndex = (currentCameraIndex + 1) % cameras.length;\n    setCurrentCameraIndex(newIndex);\n    if (stream) {\n      stream.getTracks().forEach(track => track.stop());\n    }\n    try {\n      setStatus('Switching camera...');\n      const constraints = isAudioOnly ? {\n        audio: QUALITY_PRESETS.audioOnly.audio\n      } : {\n        video: {\n          deviceId: {\n            exact: cameras[newIndex].deviceId\n          },\n          ...QUALITY_PRESETS[currentQuality].video\n        },\n        audio: QUALITY_PRESETS[currentQuality].audio\n      };\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      videoRef.current.srcObject = newStream;\n      setStatus('Camera switched!');\n    } catch (err) {\n      setStatus('Error switching camera');\n      console.error('Camera switch error:', err);\n    }\n  };\n\n  // Start recording\n  const startRecording = async () => {\n    if (!stream) {\n      setStatus('No media stream available');\n      return;\n    }\n    try {\n      setStatus('Starting recording...');\n\n      // Reset restart flag for new recording session\n      window.recordingRestarted = false;\n\n      // Start network quality monitoring\n      networkCheckInterval.current = setInterval(assessNetworkQuality, 10000);\n\n      // Clear previous chunks\n      chunksRef.current = [];\n\n      // Detect browser for potential limitations\n      const userAgent = navigator.userAgent;\n      const isChrome = userAgent.includes('Chrome');\n      const isFirefox = userAgent.includes('Firefox');\n      const isSafari = userAgent.includes('Safari') && !userAgent.includes('Chrome');\n      console.log('Browser detection:', {\n        isChrome,\n        isFirefox,\n        isSafari,\n        userAgent\n      });\n\n      // Check for supported MIME types with browser-specific preferences\n      const mimeTypes = isChrome ? ['video/webm;codecs=vp8,opus', 'video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8', 'video/webm'] : isFirefox ? ['video/webm;codecs=vp8,opus', 'video/webm;codecs=vp8', 'video/webm'] : isSafari ? ['video/mp4', 'video/webm'] : ['video/webm;codecs=vp8,opus', 'video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4'];\n      let selectedMimeType = null;\n      for (const mimeType of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(mimeType)) {\n          selectedMimeType = mimeType;\n          console.log('Using MIME type:', mimeType);\n          break;\n        }\n      }\n      if (!selectedMimeType) {\n        throw new Error('No supported video MIME type found');\n      }\n      console.log('Starting MediaRecorder with:', {\n        mimeType: selectedMimeType,\n        streamTracks: stream.getTracks().length,\n        videoTracks: stream.getVideoTracks().length,\n        audioTracks: stream.getAudioTracks().length,\n        browser: {\n          isChrome,\n          isFirefox,\n          isSafari\n        }\n      });\n      const recorder = new window.MediaRecorder(stream, {\n        mimeType: selectedMimeType\n      });\n      setMediaRecorder(recorder);\n      setRecordingTime(0);\n      recorder.ondataavailable = e => {\n        console.log('Data available:', e.data.size, 'bytes, type:', e.data.type);\n        if (e.data.size > 0) {\n          chunksRef.current.push(e.data);\n        } else {\n          console.warn('Received empty data chunk');\n        }\n      };\n      recorder.onerror = event => {\n        console.error('MediaRecorder error:', event.error);\n        console.error('Error details:', {\n          name: event.error.name,\n          message: event.error.message,\n          code: event.error.code\n        });\n        setStatus(`Recording error: ${event.error.name} - ${event.error.message}`);\n        setIsRecording(false);\n\n        // Clear intervals\n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        if (keepAliveInterval.current) {\n          clearInterval(keepAliveInterval.current);\n        }\n        if (chunkRequestInterval.current) {\n          clearInterval(chunkRequestInterval.current);\n        }\n      };\n      recorder.onstart = () => {\n        console.log('MediaRecorder started successfully');\n        console.log('Recorder state:', recorder.state);\n        setStatus('Recording started successfully');\n      };\n      recorder.onpause = () => {\n        console.log('MediaRecorder paused');\n        setStatus('Recording paused');\n      };\n      recorder.onresume = () => {\n        console.log('MediaRecorder resumed');\n        setStatus('Recording resumed');\n      };\n      recorder.onstop = async () => {\n        console.log('Recording stopped. Total chunks:', chunksRef.current.length);\n        console.log('Total data size:', chunksRef.current.reduce((total, chunk) => total + chunk.size, 0), 'bytes');\n        console.log('Final recorder state:', recorder.state);\n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        if (keepAliveInterval.current) {\n          clearInterval(keepAliveInterval.current);\n        }\n        if (chunksRef.current.length === 0) {\n          setStatus('Error: No recording data captured');\n          console.error('No chunks available for recording');\n          return;\n        }\n        const blob = new Blob(chunksRef.current, {\n          type: selectedMimeType\n        });\n        console.log('Blob created:', blob.size, 'bytes');\n        if (blob.size === 0) {\n          setStatus('Error: Recording file is empty');\n          console.error('Blob size is 0');\n          return;\n        }\n\n        // Upload to backend only - no automatic download\n        const formData = new FormData();\n        const filename = `recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.${selectedMimeType.includes('webm') ? 'webm' : 'mp4'}`;\n        formData.append('file', blob, filename);\n        try {\n          setStatus('Uploading recording...');\n          const response = await fetch(API_URL, {\n            method: 'POST',\n            body: formData\n          });\n          if (response.ok) {\n            const result = await response.json();\n            console.log('Upload successful:', result);\n            setStatus('Recording saved successfully! You can view it in the Playback page.');\n          } else {\n            const errorText = await response.text();\n            console.error('Upload failed:', errorText);\n            setStatus('Error saving recording to server');\n          }\n        } catch (err) {\n          setStatus('Error uploading recording');\n          console.error('Upload error:', err);\n        }\n      };\n\n      // Start recording without timeslice to avoid auto-stop behavior on some browsers\n      recorder.start();\n      setIsRecording(true);\n      setStatus('Recording...');\n\n      // Periodically flush data so long sessions don't accumulate too much in memory\n      chunkRequestInterval.current = setInterval(() => {\n        try {\n          if (recorder.state === 'recording') {\n            recorder.requestData();\n          }\n        } catch (e) {\n          console.log('requestData error (ignored):', e);\n        }\n      }, 5000);\n\n      // Start recording timer\n      recordingTimer.current = setInterval(() => {\n        setRecordingTime(prev => prev + 1);\n      }, 1000);\n\n      // Monitor stream state\n      streamStateCheck.current = setInterval(() => {\n        if (stream) {\n          const videoTrack = stream.getVideoTracks()[0];\n          const audioTrack = stream.getAudioTracks()[0];\n          if (videoTrack && videoTrack.readyState === 'ended') {\n            console.error('Video track ended unexpectedly');\n            setStatus('Video track ended - attempting to restart stream...');\n\n            // Try to restart the stream instead of stopping recording\n            restartStream();\n            return;\n          }\n          if (audioTrack && audioTrack.readyState === 'ended') {\n            console.error('Audio track ended unexpectedly');\n            setStatus('Audio track ended - attempting to restart stream...');\n\n            // Try to restart the stream instead of stopping recording\n            restartStream();\n            return;\n          }\n\n          // Check MediaRecorder state\n          if (recorder.state === 'inactive') {\n            console.error('MediaRecorder became inactive unexpectedly');\n            setStatus('MediaRecorder stopped unexpectedly');\n            setIsRecording(false);\n            clearInterval(streamStateCheck.current);\n          }\n\n          // Check for memory issues\n          if (performance.memory) {\n            const memoryUsage = performance.memory;\n            const memoryPercent = memoryUsage.usedJSHeapSize / memoryUsage.jsHeapSizeLimit * 100;\n            if (memoryPercent > 80) {\n              console.warn('High memory usage detected:', memoryPercent.toFixed(1) + '%');\n            }\n          }\n\n          // Log stream state every 5 seconds for more frequent monitoring\n          if (recordingTime % 5 === 0) {\n            console.log('Stream state check:', {\n              videoTrack: videoTrack ? {\n                readyState: videoTrack.readyState,\n                enabled: videoTrack.enabled\n              } : 'none',\n              audioTrack: audioTrack ? {\n                readyState: audioTrack.readyState,\n                enabled: audioTrack.enabled\n              } : 'none',\n              recorderState: recorder.state,\n              recordingTime: recordingTime,\n              chunksCount: chunksRef.current.length,\n              totalDataSize: chunksRef.current.reduce((total, chunk) => total + chunk.size, 0),\n              memoryUsage: performance.memory ? {\n                used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',\n                total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',\n                limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB'\n              } : 'Not available'\n            });\n          }\n\n          // Auto-restart if recording stops unexpectedly (but only once)\n          if (recordingTime > 10 && recorder.state === 'inactive' && !window.recordingRestarted) {\n            console.warn('Recording stopped unexpectedly, attempting restart...');\n            window.recordingRestarted = true;\n            setStatus('Recording stopped unexpectedly, attempting restart...');\n\n            // Stop current recording\n            if (recorder.state !== 'inactive') {\n              recorder.stop();\n            }\n\n            // Clear intervals\n            clearInterval(streamStateCheck.current);\n            if (recordingTimer.current) {\n              clearInterval(recordingTimer.current);\n            }\n            if (chunkRequestInterval.current) {\n              clearInterval(chunkRequestInterval.current);\n            }\n\n            // Restart recording after a short delay\n            setTimeout(() => {\n              startRecording();\n            }, 1000);\n          }\n        }\n      }, 1000);\n\n      // Store the interval reference for cleanup\n      // streamStateCheck.current = streamStateCheck;\n\n      // Add track event listeners to detect when tracks end\n      stream.getTracks().forEach(track => {\n        track.onended = () => {\n          console.warn(`${track.kind} track ended:`, track.id);\n          setStatus(`${track.kind} track ended - attempting to restart...`);\n          restartStream();\n        };\n        track.onmute = () => {\n          console.warn(`${track.kind} track muted:`, track.id);\n        };\n        track.onunmute = () => {\n          console.log(`${track.kind} track unmuted:`, track.id);\n        };\n      });\n\n      // Keep-alive mechanism to prevent track suspension\n      keepAliveInterval.current = setInterval(() => {\n        if (stream && isRecording) {\n          // Ensure video element is playing to keep tracks active\n          if (videoRef.current && videoRef.current.paused) {\n            videoRef.current.play().catch(e => console.log('Keep-alive video play error:', e));\n          }\n\n          // Log track health\n          stream.getTracks().forEach(track => {\n            if (track.readyState === 'ended') {\n              console.warn(`Track ${track.kind} ended during keep-alive check`);\n            }\n          });\n        }\n      }, 2000); // Check every 2 seconds\n\n      // Store keep-alive interval for cleanup\n      // keepAliveInterval.current = keepAliveInterval;\n    } catch (error) {\n      setStatus('Error starting recording');\n      console.error('Recording error:', error);\n    }\n  };\n\n  // Function to restart the stream when tracks end\n  const restartStream = async () => {\n    if (!isRecording) return;\n    try {\n      setStatus('Restarting stream...');\n      console.log('Attempting to restart stream...');\n\n      // Stop current recorder\n      if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n        mediaRecorder.stop();\n      }\n\n      // Clear all intervals\n      if (networkCheckInterval.current) {\n        clearInterval(networkCheckInterval.current);\n      }\n      if (recordingTimer.current) {\n        clearInterval(recordingTimer.current);\n      }\n      if (streamStateCheck.current) {\n        clearInterval(streamStateCheck.current);\n      }\n      if (keepAliveInterval.current) {\n        clearInterval(keepAliveInterval.current);\n      }\n      if (chunkRequestInterval.current) {\n        clearInterval(chunkRequestInterval.current);\n      }\n\n      // Stop current stream\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n\n      // Get new stream\n      const constraints = isAudioOnly ? {\n        audio: QUALITY_PRESETS.audioOnly.audio\n      } : {\n        video: {\n          deviceId: cameras[currentCameraIndex] ? {\n            exact: cameras[currentCameraIndex].deviceId\n          } : undefined,\n          ...QUALITY_PRESETS[currentQuality].video\n        },\n        audio: QUALITY_PRESETS[currentQuality].audio\n      };\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n\n      // Restart recording with new stream\n      setTimeout(() => {\n        startRecording();\n      }, 500);\n    } catch (error) {\n      console.error('Error restarting stream:', error);\n      setStatus('Failed to restart stream - stopping recording');\n      setIsRecording(false);\n    }\n  };\n\n  // Stop recording\n  const stopRecording = () => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      setStatus('Stopping recording...');\n    }\n  };\n\n  // Initialize camera access\n  useEffect(() => {\n    const initCamera = async () => {\n      try {\n        setStatus('Accessing camera...');\n        await getCameras();\n\n        // Start with medium quality\n        const initialStream = await navigator.mediaDevices.getUserMedia({\n          video: QUALITY_PRESETS.medium.video,\n          audio: QUALITY_PRESETS.medium.audio\n        });\n        setStream(initialStream);\n        if (videoRef.current) {\n          videoRef.current.srcObject = initialStream;\n          // Keep video element active to prevent track ending\n          videoRef.current.play().catch(e => console.log('Video play error:', e));\n        }\n        setStatus('Camera ready');\n      } catch (err) {\n        setStatus('Error accessing camera/microphone');\n        console.error('Camera access error:', err);\n      }\n    };\n    initCamera();\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (networkCheckInterval.current) {\n        clearInterval(networkCheckInterval.current);\n      }\n      if (recordingTimer.current) {\n        clearInterval(recordingTimer.current);\n      }\n      if (streamStateCheck.current) {\n        clearInterval(streamStateCheck.current);\n      }\n      if (keepAliveInterval.current) {\n        clearInterval(keepAliveInterval.current);\n      }\n      if (chunkRequestInterval.current) {\n        clearInterval(chunkRequestInterval.current);\n      }\n    };\n  }, []);\n\n  // Format recording time\n  const formatTime = seconds => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"max-w-4xl mx-auto mt-10 bg-white rounded-lg shadow p-6\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      className: \"text-2xl font-bold mb-4 text-blue-700\",\n      children: \"Record Video\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 674,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-4 p-3 bg-gray-100 rounded\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-700\",\n        children: [\"Status: \", status]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 677,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-700\",\n        children: [\"Quality: \", currentQuality, \" \", isAudioOnly && '(Audio Only)']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 678,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-700\",\n        children: [\"Network: \", networkQuality]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 679,\n        columnNumber: 9\n      }, this), isRecording && /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-red-600 font-semibold\",\n        children: [\"Recording: \", formatTime(recordingTime)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 681,\n        columnNumber: 11\n      }, this), cameras.length > 1 && /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-xs text-gray-500 mt-1\",\n        children: [\"Available cameras: \", cameras.length, \" | Current: \", ((_cameras$currentCamer = cameras[currentCameraIndex]) === null || _cameras$currentCamer === void 0 ? void 0 : _cameras$currentCamer.label) || 'Camera ' + (currentCameraIndex + 1)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 684,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 676,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"flex gap-4 mb-6 flex-wrap\",\n      children: [!isRecording ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: startRecording,\n        className: \"bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\",\n        children: \"Start Recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 692,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: stopRecording,\n        className: \"bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\",\n        children: \"Stop Recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 699,\n        columnNumber: 11\n      }, this), cameras.length > 1 && /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: switchCamera,\n        disabled: isRecording,\n        className: `px-4 py-3 rounded-lg shadow-lg font-semibold ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-yellow-600 hover:bg-yellow-700 text-white'}`,\n        children: \"Switch Camera\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 708,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex gap-2\",\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('high'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'high' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"High\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 723,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('medium'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'medium' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"Medium\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 736,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('low'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'low' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"Low\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 749,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => setQuality('audioOnly'),\n          disabled: isRecording,\n          className: `px-3 py-2 rounded shadow text-sm ${isRecording ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : currentQuality === 'audioOnly' ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`,\n          children: \"Audio Only\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 762,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 722,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 690,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"relative\",\n      children: [/*#__PURE__*/_jsxDEV(\"video\", {\n        ref: videoRef,\n        autoPlay: true,\n        playsInline: true,\n        muted: true,\n        className: \"rounded-lg shadow-lg border-2 border-blue-200 w-full h-96 bg-black\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 779,\n        columnNumber: 9\n      }, this), isAudioOnly && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"absolute top-4 left-4 p-2 bg-yellow-100 rounded text-center\",\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"text-yellow-800 text-sm font-semibold\",\n          children: \"Audio Only Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 789,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"text-yellow-700 text-xs\",\n          children: \"Poor Network Detected\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 790,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 788,\n        columnNumber: 11\n      }, this), isRecording && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"absolute top-4 right-4 p-2 bg-red-600 rounded text-white\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"flex items-center gap-2\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"w-3 h-3 bg-white rounded-full animate-pulse\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 797,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"font-semibold\",\n            children: \"REC\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 798,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 796,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 795,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 778,\n      columnNumber: 7\n    }, this), isRecording && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-4 p-3 bg-red-100 rounded\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-red-700 text-sm\",\n        children: [\"\\uD83D\\uDD34 Recording in progress... \", formatTime(recordingTime)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 806,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 805,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-6 p-4 bg-blue-50 rounded\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        className: \"font-semibold text-blue-800 mb-2\",\n        children: \"Adaptive Quality Features:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 811,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        className: \"text-sm text-blue-700 space-y-1\",\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Automatic quality adjustment based on network conditions\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 813,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Fallback to audio-only recording in poor network\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 814,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Manual quality control for optimal recording\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 815,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Real-time network quality monitoring\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 816,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"\\u2022 Automatic camera switching support\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 817,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 812,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 810,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 673,\n    columnNumber: 5\n  }, this);\n};\n_s(Record, \"6QQX+I0ZNc+zWPDBU3yIVKqDnf0=\");\n_c = Record;\nexport default Record;\nvar _c;\n$RefreshReg$(_c, \"Record\");","map":{"version":3,"names":["React","useRef","useState","useEffect","toast","jsxDEV","_jsxDEV","API_URL","QUALITY_PRESETS","high","video","width","height","frameRate","bitrate","audio","sampleRate","channelCount","medium","low","audioOnly","Record","_s","_cameras$currentCamer","isRecording","setIsRecording","mediaRecorder","setMediaRecorder","chunks","setChunks","stream","setStream","cameras","setCameras","currentCameraIndex","setCurrentCameraIndex","currentQuality","setCurrentQuality","isAudioOnly","setIsAudioOnly","networkQuality","setNetworkQuality","recordingTime","setRecordingTime","status","setStatus","videoRef","recordingTimer","networkCheckInterval","streamStateCheck","keepAliveInterval","chunkRequestInterval","chunksRef","getCameras","devices","navigator","mediaDevices","enumerateDevices","videoDevices","filter","device","kind","err","console","error","assessNetworkQuality","startTime","performance","now","response","fetch","method","cache","endTime","latency","newQuality","newAudioOnly","ok","adjustRecordingQuality","toFixed","quality","getTracks","forEach","track","stop","constraints","deviceId","exact","undefined","newStream","getUserMedia","current","srcObject","message","setQuality","switchCamera","length","newIndex","startRecording","window","recordingRestarted","setInterval","userAgent","isChrome","includes","isFirefox","isSafari","log","mimeTypes","selectedMimeType","mimeType","MediaRecorder","isTypeSupported","Error","streamTracks","videoTracks","getVideoTracks","audioTracks","getAudioTracks","browser","recorder","ondataavailable","e","data","size","type","push","warn","onerror","event","name","code","clearInterval","onstart","state","onpause","onresume","onstop","reduce","total","chunk","blob","Blob","formData","FormData","filename","Date","toISOString","slice","replace","append","body","result","json","errorText","text","start","requestData","prev","videoTrack","audioTrack","readyState","restartStream","memory","memoryUsage","memoryPercent","usedJSHeapSize","jsHeapSizeLimit","enabled","recorderState","chunksCount","totalDataSize","used","Math","round","totalJSHeapSize","limit","setTimeout","onended","id","onmute","onunmute","paused","play","catch","stopRecording","initCamera","initialStream","formatTime","seconds","mins","floor","secs","toString","padStart","className","children","fileName","_jsxFileName","lineNumber","columnNumber","label","onClick","disabled","ref","autoPlay","playsInline","muted","_c","$RefreshReg$"],"sources":["/Users/dhruva_kumar/Work Space/final project/client/src/pages/Record.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport toast from 'react-hot-toast';\n\nconst API_URL = 'http://10.28.159.141:5001/api/recordings';  //http://10.28.159.141:5001/\n\n// Quality presets for adaptive recording\nconst QUALITY_PRESETS = {\n  high: {\n    video: { width: 1280, height: 720, frameRate: 30, bitrate: 2500000 },\n    audio: { sampleRate: 48000, channelCount: 2, bitrate: 128000 }\n  },\n  medium: {\n    video: { width: 854, height: 480, frameRate: 25, bitrate: 1000000 },\n    audio: { sampleRate: 44100, channelCount: 2, bitrate: 96000 }\n  },\n  low: {\n    video: { width: 640, height: 360, frameRate: 20, bitrate: 500000 },\n    audio: { sampleRate: 22050, channelCount: 1, bitrate: 64000 }\n  },\n  audioOnly: {\n    video: false,\n    audio: { sampleRate: 22050, channelCount: 1, bitrate: 32000 }\n  }\n};\n\nconst Record = () => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [chunks, setChunks] = useState([]);\n  const [stream, setStream] = useState(null);\n  const [cameras, setCameras] = useState([]);\n  const [currentCameraIndex, setCurrentCameraIndex] = useState(0);\n  const [currentQuality, setCurrentQuality] = useState('medium');\n  const [isAudioOnly, setIsAudioOnly] = useState(false);\n  const [networkQuality, setNetworkQuality] = useState('unknown');\n  const [recordingTime, setRecordingTime] = useState(0);\n  const [status, setStatus] = useState('Ready to record');\n\n  const videoRef = useRef();\n  const recordingTimer = useRef(null);\n  const networkCheckInterval = useRef(null);\n  const streamStateCheck = useRef(null);\n  const keepAliveInterval = useRef(null);\n  const chunkRequestInterval = useRef(null);\n  const chunksRef = useRef([]); // Use ref to store chunks\n\n  // Get available cameras\n  const getCameras = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const videoDevices = devices.filter(device => device.kind === 'videoinput');\n      setCameras(videoDevices);\n      return videoDevices;\n    } catch (err) {\n      console.error('Error getting cameras:', err);\n      return [];\n    }\n  };\n\n  // Assess network quality for recording\n  const assessNetworkQuality = async () => {\n    try {\n      // Simple network quality assessment for recording\n      const startTime = performance.now();\n      const response = await fetch(API_URL, { \n        method: 'HEAD',\n        cache: 'no-cache'\n      });\n      const endTime = performance.now();\n      const latency = endTime - startTime;\n\n      let newQuality = currentQuality;\n      let newAudioOnly = isAudioOnly;\n\n      if (latency > 1000 || !response.ok) {\n        // Poor network - switch to audio only\n        newQuality = 'audioOnly';\n        newAudioOnly = true;\n        setNetworkQuality('poor');\n      } else if (latency > 500) {\n        // Medium network - use low quality\n        newQuality = 'low';\n        newAudioOnly = false;\n        setNetworkQuality('medium');\n      } else if (latency > 200) {\n        // Good network - use medium quality\n        newQuality = 'medium';\n        newAudioOnly = false;\n        setNetworkQuality('good');\n      } else {\n        // Excellent network - use high quality\n        newQuality = 'high';\n        newAudioOnly = false;\n        setNetworkQuality('excellent');\n      }\n\n      // Apply quality changes if needed\n      if (newQuality !== currentQuality || newAudioOnly !== isAudioOnly) {\n        await adjustRecordingQuality(newQuality, newAudioOnly);\n      }\n\n      setStatus(`Network: ${networkQuality} (${latency.toFixed(0)}ms latency)`);\n    } catch (error) {\n      console.error('Error assessing network quality:', error);\n      // If network check fails, assume poor network and switch to audio only\n      if (currentQuality !== 'audioOnly') {\n        await adjustRecordingQuality('audioOnly', true);\n      }\n    }\n  };\n\n  // Adjust recording quality based on network conditions\n  const adjustRecordingQuality = async (quality, audioOnly = false) => {\n    if (isRecording) {\n      setStatus('Cannot adjust quality while recording');\n      return;\n    }\n\n    try {\n      setStatus(`Adjusting quality to: ${quality}${audioOnly ? ' (audio only)' : ''}`);\n      \n      // Stop current stream if exists\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      \n      // Get new stream with adjusted quality\n      const constraints = audioOnly ? \n        { audio: QUALITY_PRESETS.audioOnly.audio } :\n        { \n          video: { \n            deviceId: cameras[currentCameraIndex] ? { exact: cameras[currentCameraIndex].deviceId } : undefined,\n            ...QUALITY_PRESETS[quality].video \n          },\n          audio: QUALITY_PRESETS[quality].audio\n        };\n\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n\n      setCurrentQuality(quality);\n      setIsAudioOnly(audioOnly);\n      setStatus(`Quality adjusted to ${quality}`);\n    } catch (error) {\n      console.error('Error adjusting recording quality:', error);\n      setStatus(`Error adjusting quality: ${error.message}`);\n    }\n  };\n\n  // Manual quality adjustment\n  const setQuality = async (quality) => {\n    await adjustRecordingQuality(quality, quality === 'audioOnly');\n  };\n\n  // Switch camera\n  const switchCamera = async () => {\n    if (cameras.length < 2) {\n      setStatus('Only one camera available');\n      return;\n    }\n\n    if (isRecording) {\n      setStatus('Cannot switch camera while recording');\n      return;\n    }\n\n    const newIndex = (currentCameraIndex + 1) % cameras.length;\n    setCurrentCameraIndex(newIndex);\n    \n    if (stream) {\n      stream.getTracks().forEach(track => track.stop());\n    }\n\n    try {\n      setStatus('Switching camera...');\n      const constraints = isAudioOnly ? \n        { audio: QUALITY_PRESETS.audioOnly.audio } :\n        { \n          video: { \n            deviceId: { exact: cameras[newIndex].deviceId }, \n            ...QUALITY_PRESETS[currentQuality].video \n          },\n          audio: QUALITY_PRESETS[currentQuality].audio\n        };\n\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      videoRef.current.srcObject = newStream;\n      setStatus('Camera switched!');\n    } catch (err) {\n      setStatus('Error switching camera');\n      console.error('Camera switch error:', err);\n    }\n  };\n\n  // Start recording\n  const startRecording = async () => {\n    if (!stream) {\n      setStatus('No media stream available');\n      return;\n    }\n\n    try {\n      setStatus('Starting recording...');\n      \n      // Reset restart flag for new recording session\n      window.recordingRestarted = false;\n      \n      // Start network quality monitoring\n      networkCheckInterval.current = setInterval(assessNetworkQuality, 10000);\n      \n      // Clear previous chunks\n      chunksRef.current = [];\n      \n      // Detect browser for potential limitations\n      const userAgent = navigator.userAgent;\n      const isChrome = userAgent.includes('Chrome');\n      const isFirefox = userAgent.includes('Firefox');\n      const isSafari = userAgent.includes('Safari') && !userAgent.includes('Chrome');\n      \n      console.log('Browser detection:', { isChrome, isFirefox, isSafari, userAgent });\n      \n      // Check for supported MIME types with browser-specific preferences\n      const mimeTypes = isChrome ? [\n        'video/webm;codecs=vp8,opus',\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=vp8',\n        'video/webm'\n      ] : isFirefox ? [\n        'video/webm;codecs=vp8,opus',\n        'video/webm;codecs=vp8',\n        'video/webm'\n      ] : isSafari ? [\n        'video/mp4',\n        'video/webm'\n      ] : [\n        'video/webm;codecs=vp8,opus',\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=vp8',\n        'video/webm',\n        'video/mp4'\n      ];\n      \n      let selectedMimeType = null;\n      for (const mimeType of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(mimeType)) {\n          selectedMimeType = mimeType;\n          console.log('Using MIME type:', mimeType);\n          break;\n        }\n      }\n      \n      if (!selectedMimeType) {\n        throw new Error('No supported video MIME type found');\n      }\n      \n      console.log('Starting MediaRecorder with:', {\n        mimeType: selectedMimeType,\n        streamTracks: stream.getTracks().length,\n        videoTracks: stream.getVideoTracks().length,\n        audioTracks: stream.getAudioTracks().length,\n        browser: { isChrome, isFirefox, isSafari }\n      });\n      \n      const recorder = new window.MediaRecorder(stream, {\n        mimeType: selectedMimeType\n      });\n      \n      setMediaRecorder(recorder);\n      setRecordingTime(0);\n      \n      recorder.ondataavailable = (e) => {\n        console.log('Data available:', e.data.size, 'bytes, type:', e.data.type);\n        if (e.data.size > 0) {\n          chunksRef.current.push(e.data);\n        } else {\n          console.warn('Received empty data chunk');\n        }\n      };\n      \n      recorder.onerror = (event) => {\n        console.error('MediaRecorder error:', event.error);\n        console.error('Error details:', {\n          name: event.error.name,\n          message: event.error.message,\n          code: event.error.code\n        });\n        setStatus(`Recording error: ${event.error.name} - ${event.error.message}`);\n        setIsRecording(false);\n        \n        // Clear intervals\n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        if (keepAliveInterval.current) {\n          clearInterval(keepAliveInterval.current);\n        }\n        if (chunkRequestInterval.current) {\n          clearInterval(chunkRequestInterval.current);\n        }\n      };\n      \n      recorder.onstart = () => {\n        console.log('MediaRecorder started successfully');\n        console.log('Recorder state:', recorder.state);\n        setStatus('Recording started successfully');\n      };\n      \n      recorder.onpause = () => {\n        console.log('MediaRecorder paused');\n        setStatus('Recording paused');\n      };\n      \n      recorder.onresume = () => {\n        console.log('MediaRecorder resumed');\n        setStatus('Recording resumed');\n      };\n      \n      recorder.onstop = async () => {\n        console.log('Recording stopped. Total chunks:', chunksRef.current.length);\n        console.log('Total data size:', chunksRef.current.reduce((total, chunk) => total + chunk.size, 0), 'bytes');\n        console.log('Final recorder state:', recorder.state);\n        \n        if (networkCheckInterval.current) {\n          clearInterval(networkCheckInterval.current);\n        }\n        if (recordingTimer.current) {\n          clearInterval(recordingTimer.current);\n        }\n        if (streamStateCheck.current) {\n          clearInterval(streamStateCheck.current);\n        }\n        if (keepAliveInterval.current) {\n          clearInterval(keepAliveInterval.current);\n        }\n        \n        if (chunksRef.current.length === 0) {\n          setStatus('Error: No recording data captured');\n          console.error('No chunks available for recording');\n          return;\n        }\n        \n        const blob = new Blob(chunksRef.current, { type: selectedMimeType });\n        console.log('Blob created:', blob.size, 'bytes');\n        \n        if (blob.size === 0) {\n          setStatus('Error: Recording file is empty');\n          console.error('Blob size is 0');\n          return;\n        }\n        \n        // Upload to backend only - no automatic download\n        const formData = new FormData();\n        const filename = `recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.${selectedMimeType.includes('webm') ? 'webm' : 'mp4'}`;\n        formData.append('file', blob, filename);\n        \n        try {\n          setStatus('Uploading recording...');\n          const response = await fetch(API_URL, { \n            method: 'POST', \n            body: formData \n          });\n          \n          if (response.ok) {\n            const result = await response.json();\n            console.log('Upload successful:', result);\n            setStatus('Recording saved successfully! You can view it in the Playback page.');\n          } else {\n            const errorText = await response.text();\n            console.error('Upload failed:', errorText);\n            setStatus('Error saving recording to server');\n          }\n        } catch (err) {\n          setStatus('Error uploading recording');\n          console.error('Upload error:', err);\n        }\n      };\n      \n      // Start recording without timeslice to avoid auto-stop behavior on some browsers\n      recorder.start();\n      setIsRecording(true);\n      setStatus('Recording...');\n\n      // Periodically flush data so long sessions don't accumulate too much in memory\n      chunkRequestInterval.current = setInterval(() => {\n        try {\n          if (recorder.state === 'recording') {\n            recorder.requestData();\n          }\n        } catch (e) {\n          console.log('requestData error (ignored):', e);\n        }\n      }, 5000);\n      \n      // Start recording timer\n      recordingTimer.current = setInterval(() => {\n        setRecordingTime(prev => prev + 1);\n      }, 1000);\n      \n      // Monitor stream state\n      streamStateCheck.current = setInterval(() => {\n        if (stream) {\n          const videoTrack = stream.getVideoTracks()[0];\n          const audioTrack = stream.getAudioTracks()[0];\n          \n          if (videoTrack && videoTrack.readyState === 'ended') {\n            console.error('Video track ended unexpectedly');\n            setStatus('Video track ended - attempting to restart stream...');\n            \n            // Try to restart the stream instead of stopping recording\n            restartStream();\n            return;\n          }\n          \n          if (audioTrack && audioTrack.readyState === 'ended') {\n            console.error('Audio track ended unexpectedly');\n            setStatus('Audio track ended - attempting to restart stream...');\n            \n            // Try to restart the stream instead of stopping recording\n            restartStream();\n            return;\n          }\n          \n          // Check MediaRecorder state\n          if (recorder.state === 'inactive') {\n            console.error('MediaRecorder became inactive unexpectedly');\n            setStatus('MediaRecorder stopped unexpectedly');\n            setIsRecording(false);\n            clearInterval(streamStateCheck.current);\n          }\n          \n          // Check for memory issues\n          if (performance.memory) {\n            const memoryUsage = performance.memory;\n            const memoryPercent = (memoryUsage.usedJSHeapSize / memoryUsage.jsHeapSizeLimit) * 100;\n            if (memoryPercent > 80) {\n              console.warn('High memory usage detected:', memoryPercent.toFixed(1) + '%');\n            }\n          }\n          \n          // Log stream state every 5 seconds for more frequent monitoring\n          if (recordingTime % 5 === 0) {\n            console.log('Stream state check:', {\n              videoTrack: videoTrack ? { readyState: videoTrack.readyState, enabled: videoTrack.enabled } : 'none',\n              audioTrack: audioTrack ? { readyState: audioTrack.readyState, enabled: audioTrack.enabled } : 'none',\n              recorderState: recorder.state,\n              recordingTime: recordingTime,\n              chunksCount: chunksRef.current.length,\n              totalDataSize: chunksRef.current.reduce((total, chunk) => total + chunk.size, 0),\n              memoryUsage: performance.memory ? {\n                used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',\n                total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',\n                limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB'\n              } : 'Not available'\n            });\n          }\n          \n          // Auto-restart if recording stops unexpectedly (but only once)\n          if (recordingTime > 10 && recorder.state === 'inactive' && !window.recordingRestarted) {\n            console.warn('Recording stopped unexpectedly, attempting restart...');\n            window.recordingRestarted = true;\n            setStatus('Recording stopped unexpectedly, attempting restart...');\n            \n            // Stop current recording\n            if (recorder.state !== 'inactive') {\n              recorder.stop();\n            }\n            \n            // Clear intervals\n            clearInterval(streamStateCheck.current);\n            if (recordingTimer.current) {\n              clearInterval(recordingTimer.current);\n            }\n            if (chunkRequestInterval.current) {\n              clearInterval(chunkRequestInterval.current);\n            }\n            \n            // Restart recording after a short delay\n            setTimeout(() => {\n              startRecording();\n            }, 1000);\n          }\n        }\n      }, 1000);\n      \n      // Store the interval reference for cleanup\n      // streamStateCheck.current = streamStateCheck;\n      \n      // Add track event listeners to detect when tracks end\n      stream.getTracks().forEach(track => {\n        track.onended = () => {\n          console.warn(`${track.kind} track ended:`, track.id);\n          setStatus(`${track.kind} track ended - attempting to restart...`);\n          restartStream();\n        };\n        \n        track.onmute = () => {\n          console.warn(`${track.kind} track muted:`, track.id);\n        };\n        \n        track.onunmute = () => {\n          console.log(`${track.kind} track unmuted:`, track.id);\n        };\n      });\n      \n      // Keep-alive mechanism to prevent track suspension\n      keepAliveInterval.current = setInterval(() => {\n        if (stream && isRecording) {\n          // Ensure video element is playing to keep tracks active\n          if (videoRef.current && videoRef.current.paused) {\n            videoRef.current.play().catch(e => console.log('Keep-alive video play error:', e));\n          }\n          \n          // Log track health\n          stream.getTracks().forEach(track => {\n            if (track.readyState === 'ended') {\n              console.warn(`Track ${track.kind} ended during keep-alive check`);\n            }\n          });\n        }\n      }, 2000); // Check every 2 seconds\n      \n      // Store keep-alive interval for cleanup\n      // keepAliveInterval.current = keepAliveInterval;\n      \n    } catch (error) {\n      setStatus('Error starting recording');\n      console.error('Recording error:', error);\n    }\n  };\n\n  // Function to restart the stream when tracks end\n  const restartStream = async () => {\n    if (!isRecording) return;\n    \n    try {\n      setStatus('Restarting stream...');\n      console.log('Attempting to restart stream...');\n      \n      // Stop current recorder\n      if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n        mediaRecorder.stop();\n      }\n      \n      // Clear all intervals\n      if (networkCheckInterval.current) {\n        clearInterval(networkCheckInterval.current);\n      }\n      if (recordingTimer.current) {\n        clearInterval(recordingTimer.current);\n      }\n      if (streamStateCheck.current) {\n        clearInterval(streamStateCheck.current);\n      }\n      if (keepAliveInterval.current) {\n        clearInterval(keepAliveInterval.current);\n      }\n      if (chunkRequestInterval.current) {\n        clearInterval(chunkRequestInterval.current);\n      }\n      \n      // Stop current stream\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      \n      // Get new stream\n      const constraints = isAudioOnly ? \n        { audio: QUALITY_PRESETS.audioOnly.audio } :\n        { \n          video: { \n            deviceId: cameras[currentCameraIndex] ? { exact: cameras[currentCameraIndex].deviceId } : undefined,\n            ...QUALITY_PRESETS[currentQuality].video \n          },\n          audio: QUALITY_PRESETS[currentQuality].audio\n        };\n\n      const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(newStream);\n      \n      if (videoRef.current) {\n        videoRef.current.srcObject = newStream;\n      }\n      \n      // Restart recording with new stream\n      setTimeout(() => {\n        startRecording();\n      }, 500);\n      \n    } catch (error) {\n      console.error('Error restarting stream:', error);\n      setStatus('Failed to restart stream - stopping recording');\n      setIsRecording(false);\n    }\n  };\n\n  // Stop recording\n  const stopRecording = () => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      setStatus('Stopping recording...');\n    }\n  };\n\n  // Initialize camera access\n  useEffect(() => {\n    const initCamera = async () => {\n      try {\n        setStatus('Accessing camera...');\n        await getCameras();\n        \n        // Start with medium quality\n        const initialStream = await navigator.mediaDevices.getUserMedia({\n          video: QUALITY_PRESETS.medium.video,\n          audio: QUALITY_PRESETS.medium.audio\n        });\n        \n        setStream(initialStream);\n        if (videoRef.current) {\n          videoRef.current.srcObject = initialStream;\n          // Keep video element active to prevent track ending\n          videoRef.current.play().catch(e => console.log('Video play error:', e));\n        }\n        setStatus('Camera ready');\n      } catch (err) {\n        setStatus('Error accessing camera/microphone');\n        console.error('Camera access error:', err);\n      }\n    };\n\n    initCamera();\n\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (networkCheckInterval.current) {\n        clearInterval(networkCheckInterval.current);\n      }\n      if (recordingTimer.current) {\n        clearInterval(recordingTimer.current);\n      }\n      if (streamStateCheck.current) {\n        clearInterval(streamStateCheck.current);\n      }\n      if (keepAliveInterval.current) {\n        clearInterval(keepAliveInterval.current);\n      }\n      if (chunkRequestInterval.current) {\n        clearInterval(chunkRequestInterval.current);\n      }\n    };\n  }, []);\n\n  // Format recording time\n  const formatTime = (seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  return (\n    <div className=\"max-w-4xl mx-auto mt-10 bg-white rounded-lg shadow p-6\">\n      <h2 className=\"text-2xl font-bold mb-4 text-blue-700\">Record Video</h2>\n      \n      <div className=\"mb-4 p-3 bg-gray-100 rounded\">\n        <p className=\"text-sm text-gray-700\">Status: {status}</p>\n        <p className=\"text-sm text-gray-700\">Quality: {currentQuality} {isAudioOnly && '(Audio Only)'}</p>\n        <p className=\"text-sm text-gray-700\">Network: {networkQuality}</p>\n        {isRecording && (\n          <p className=\"text-sm text-red-600 font-semibold\">Recording: {formatTime(recordingTime)}</p>\n        )}\n        {cameras.length > 1 && (\n          <p className=\"text-xs text-gray-500 mt-1\">\n            Available cameras: {cameras.length} | Current: {cameras[currentCameraIndex]?.label || 'Camera ' + (currentCameraIndex + 1)}\n          </p>\n        )}\n      </div>\n\n      <div className=\"flex gap-4 mb-6 flex-wrap\">\n        {!isRecording ? (\n          <button\n            onClick={startRecording}\n            className=\"bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\"\n          >\n            Start Recording\n          </button>\n        ) : (\n          <button\n            onClick={stopRecording}\n            className=\"bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg shadow-lg font-semibold\"\n          >\n            Stop Recording\n          </button>\n        )}\n        \n        {cameras.length > 1 && (\n          <button\n            onClick={switchCamera}\n            disabled={isRecording}\n            className={`px-4 py-3 rounded-lg shadow-lg font-semibold ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : 'bg-yellow-600 hover:bg-yellow-700 text-white'\n            }`}\n          >\n            Switch Camera\n          </button>\n        )}\n        \n        {/* Manual Quality Controls */}\n        <div className=\"flex gap-2\">\n          <button\n            onClick={() => setQuality('high')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'high' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            High\n          </button>\n          <button\n            onClick={() => setQuality('medium')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'medium' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            Medium\n          </button>\n          <button\n            onClick={() => setQuality('low')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'low' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            Low\n          </button>\n          <button\n            onClick={() => setQuality('audioOnly')}\n            disabled={isRecording}\n            className={`px-3 py-2 rounded shadow text-sm ${\n              isRecording \n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed' \n                : currentQuality === 'audioOnly' \n                  ? 'bg-green-600 text-white' \n                  : 'bg-gray-300 text-gray-700 hover:bg-gray-400'\n            }`}\n          >\n            Audio Only\n          </button>\n        </div>\n      </div>\n\n      <div className=\"relative\">\n        <video\n          ref={videoRef}\n          autoPlay\n          playsInline\n          muted\n          className=\"rounded-lg shadow-lg border-2 border-blue-200 w-full h-96 bg-black\"\n        />\n        \n        {isAudioOnly && (\n          <div className=\"absolute top-4 left-4 p-2 bg-yellow-100 rounded text-center\">\n            <p className=\"text-yellow-800 text-sm font-semibold\">Audio Only Mode</p>\n            <p className=\"text-yellow-700 text-xs\">Poor Network Detected</p>\n          </div>\n        )}\n        \n        {isRecording && (\n          <div className=\"absolute top-4 right-4 p-2 bg-red-600 rounded text-white\">\n            <div className=\"flex items-center gap-2\">\n              <div className=\"w-3 h-3 bg-white rounded-full animate-pulse\"></div>\n              <span className=\"font-semibold\">REC</span>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {isRecording && (\n        <div className=\"mt-4 p-3 bg-red-100 rounded\">\n          <p className=\"text-red-700 text-sm\"> Recording in progress... {formatTime(recordingTime)}</p>\n        </div>\n      )}\n\n      <div className=\"mt-6 p-4 bg-blue-50 rounded\">\n        <h3 className=\"font-semibold text-blue-800 mb-2\">Adaptive Quality Features:</h3>\n        <ul className=\"text-sm text-blue-700 space-y-1\">\n          <li> Automatic quality adjustment based on network conditions</li>\n          <li> Fallback to audio-only recording in poor network</li>\n          <li> Manual quality control for optimal recording</li>\n          <li> Real-time network quality monitoring</li>\n          <li> Automatic camera switching support</li>\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport default Record; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}